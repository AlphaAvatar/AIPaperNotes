论文链接：https://arxiv.org/pdf/2501.12948v2

代码链接：

# 摘要

通用推理一直是人工智能领域长期存在的艰巨挑战。近年来，以大语言模型（LLM）和思维链提示为代表的突破性进展，在基础推理任务上取得了显著成效。然而，这些成功很大程度上依赖于大量的人工标注示例，模型的能力对于更复杂的问题仍然不足。本文表明，可以通过纯强化学习（RL）激励 LLM 的推理能力，从而无需人工标注推理轨迹。所提出的 RL 框架促进了高级推理模式的涌现式发展，例如自我反思、验证和动态策略适应。因此，训练后的模型在数学、编程竞赛和 STEM 领域等**可验证任务**上取得了优异的性能，超越了通过传统有监督学习在人工样例上训练的同类模型。此外，这些大规模模型展现出的**涌现式推理模式**可以系统地用于指导和增强小型模型的推理能力。

# 1.介绍

推理能力是人类智能的基石，它使人类能够完成从数学问题解决到逻辑推理和编程等各种复杂的认知任务。人工智能领域的最新进展表明，大语言模型（LLM）在规模足够大时可以展现出涌现行为，包括推理能力。然而，在预训练阶段实现这种能力通常需要大量的计算资源。与此同时，一项互补的研究表明，通过思维链（CoT）提示可以有效地增强大语言模型。这项技术包括提供精心设计的少样本示例，或使用诸如“Let’s think step by step”之类的极简提示，使模型能够生成中间推理步骤，从而显著提高其在复杂任务上的性能。类似地，当模型在后训练阶段学习高质量的多步骤推理轨迹时，也观察到了性能的进一步提升。尽管这些方法有效，但它们也存在明显的局限性。它们对人工标注的推理轨迹的依赖阻碍了可扩展性，并引入了认知偏差。此外，由于模型被限制为复制人类的思维过程，其性能本质上受到人类提供的示例的限制，这阻碍了对更优的、非人类式推理路径的探索。

为了解决这些问题，我们旨在**探索 LLM 在强化学习（RL）框架下通过自我进化发展推理能力的潜力**，并尽可能减少对人工标注的依赖。具体而言，我们基于 DeepSeek-V3-Base 构建模型，并采用组相对策略优化（GRPO）作为强化学习框架。奖赏信号完全基于最终预测结果与真实答案的匹配程度，而不对推理过程本身施加任何约束。值得注意的是，我们跳过了强化学习训练之前的传统有监督微调（SFT）阶段。这一设计选择源于我们的假设：**人类定义的推理模式可能会限制模型的探索**，而不受限制的强化学习训练能够更好地激励低 LLM涌现出新的推理能力。通过这一过程（详见第2节），我们的模型（称为DeepSeek-R1-Zero）自然地发展出了多样化且复杂的推理行为。在解决推理问题时，该模型倾向于生成更长的响应，并在每个响应中融入验证、反思和探索其他方法。虽然我们没有明确地教模型如何推理，但它通过强化学习成功地学习到了更优的推理策略。

尽管 DeepSeek-R1-Zero 展现出卓越的推理能力，但它也面临着一些挑战，例如可读性差和语言混合，有时会在同一条思路回复中混用英语和中文。此外，DeepSeek-R1-Zero 基于规则的强化学习训练阶段过于专注于推理任务，导致其在写作和开放领域问答等更广泛的领域表现有限。为了应对这些挑战，我们引入了 DeepSeek-R1，这是一个通过多阶段学习框架训练的模型，该框架融合了拒绝采样、强化学习和有监督微调，详见第 3 节。该训练流程使 DeepSeek-R1 能够继承其前身 DeepSeek-R1-Zero 的推理能力，同时通过额外的非推理数据使模型行为更符合人类偏好。

为了让更多人能够以更低的能耗成本使用强大的AI，我们蒸馏了几个更小的模型并将其公开发布。这些蒸馏后的模型展现出强大的推理能力，性能超越了其原始的指令微调版本。我们相信，这些指令微调版本也将为研究界做出重大贡献，为理解长链思维（CoT）推理模型的底层机制以及促进更强大推理模型的开发提供宝贵的资源。我们已在 https://huggingface.co/deepseek-ai 向公众发布了 DeepSeek-R1 系列模型。

# 2.DeepSeek-R1-Zero

我们首先详细阐述 DeepSeek-R1-Zero 的训练过程，该模型完全依赖于强化学习，而没有进行有监督微调。为了提高大规模强化学习的效率，我们采用了组相对策略优化（GRPO）。

## 2.1 Group Relative Policy Optimization

GRPO 是我们采用的强化学习算法，用于训练 DeepSeekR1-Zero 和 DeepSeek-R1。它最初是为了简化训练过程并减少近端策略优化（PPO）的资源消耗而提出的，PPO 广泛用于 LLM 的 RL 阶段。

对于每个问题 $q$，GRPO 从旧策略 $\pi_{\theta_{old}}$ 中抽取一组输出 $\{o_1, o_2, · · · , o_G\}$，然后通过最大化以下目标来优化策略模型 $\pi_{\theta}$：

$$\begin{array}{cc}
\mathcal J_{GRPO}(\theta)=\mathbb E[q\sim P(Q),\{o_i\}^G_{i=1}\sim\pi_{\theta_{old}}(O|q)]\\
\frac{1}{G}\sum^G_{i=1}(min(\frac{\pi_{\theta}(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}A_i, \frac{\pi_{\theta}(o_i|q)}{\pi_{\theta_{old}}(o_i|q)},1-𝜀, 1+𝜀)A_i)-\beta\mathbb D_{KL}(\pi_{\theta}||\pi_{ref})),
\end{array}\tag{1}$$

$$\mathbb D_{KL}(\pi_{\theta}||\pi_{ref})=\frac{\pi_{ref}(o_i|q)}{\pi_{\theta}(o_i|q)}-log\frac{\pi_{ref}(o_i|q)}{\pi_{\theta}(o_i|q)}-1,\tag{2}$$

其中 $\pi_{ref}$ 是参考策略，$𝜀$ 和 $𝛽$ 是超参数，$A_i$ 是优势函数，使用一组奖赏 $\{r_1,r_2, . . . ,r_G\}$ 计算得出，这些奖赏对应于每个组内的输出：

$$A_i=\frac{r_i-mean(\{r_1,r_2,...,r_G\})}{std(\{r_1,r_2,...,r_G\})}.\tag{3}$$

我们在补充材料 A.3 中对 GRPO 和 PPO 进行了比较。为了训练 DeepSeek-R1-Zero 模型，我们将学习率设置为 3e-6，KL 系数设置为 0.001，并将 rollout 的采样 temperature 设置为 1。对于每个问题，我们在 8.2k 步之前采样 16 个输出，最大长度为 32,768 个 token，之后采样 65,536 个 token。因此，DeepSeek-R1-Zero 模型的性能和响应长度在 8.2k 步均出现了显著提升，训练总共持续了 10,400 步，相当于 1.6 个训练 epoch。每个训练步长包含 32 个不同的问题，因此训练 batch size 为 512。每 400 步，我们将 ref 模型替换为最新的策略模型。为了加速训练，每次 rollout 生成 8,192 个输出，这些输出被随机分成 16 个小 batch，并且只训练一个 inner epoch。

我们在补充材料 B.1 中描述了高性能 RL 基础设施，确保了可扩展和高效的训练。

## 2.2 Reward Design

奖赏是训练信号的来源，它决定了强化学习优化的方向。对于 DeepSeek-R1-Zero，我们采用基于规则的奖赏机制，为数学、编码和逻辑推理领域的数据提供精确的反馈。我们的基于规则的奖赏系统主要包含两种类型的奖励：准确率奖励和格式奖励。

**Accuracy rewards** 用于评估响应是否正确。例如，对于结果确定的数学问题，模型需要以指定格式（例如，在一个方框内）提供最终答案，从而实现基于规则的可靠正确性验证。类似地，对于代码竞赛题目，可以使用编译器根据一组预定义的测试用例来评估模型的响应，从而生成关于正确性的客观反馈。

**Format rewards** 机制通过强制执行特定的格式要求，对准确性奖赏模型进行了补充。具体而言，该机制鼓励模型将其推理过程封装在指定的标签内，即“$\texttt{<think>}$”和“$\texttt{</think>}$”。这确保了模型的思维过程得到清晰的描述，从而增强了模型的可解释性，并有助于后续的分析。

$$Reward_{rule}=Reward_{acc}+Reward_{format}\tag{4}$$

准确率奖励和格式奖赏以相同的权重组合。值得注意的是，我们不将神经奖赏模型（无论是基于结果的还是基于过程的）应用于推理任务。这一决定基于我们的观察：**神经奖赏模型在大规模强化学习过程中容易受到奖赏操纵**。此外，重新训练此类模型需要大量的计算资源，并会增加训练流程的复杂性，从而使整体优化过程更加复杂。

## 2.3 Incentivize Reasoning Capability in LLMs

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9f36245f3b2b4832870580b4d8e6dd4d.png)


具体来说，我们基于 DeepSeek-V3 模型应用强化学习 (RL) 技术来训练 DeepSeek-R1-Zero。在训练过程中，我们设计了一个简单的模板，要求 DeepSeek-R1-Zero 首先生成推理过程，然后再给出最终答案。我们特意将约束条件限制在这种结构化格式内，避免任何内容相关的偏差，以确保能够准确观察模型在强化学习过程中的自然演进。

图 1(a) 展示了 DeepSeek-R1-Zero 在 AIME 2024 基准测试中，整个强化学习训练过程中的性能轨迹。其中，AIME 2024 的平均 pass@1 分数显著提升，从最初的 15.6% 跃升至 77.9%。此外，通过利用 self-consistency  解码，模型的性能可以进一步提升，达到 86.7% 的准确率。这一性能显著超越了所有人类参赛者的平均水平。除了数学竞赛之外，如图 10 所示，DeepSeek-R1-Zero 在编程竞赛以及研究生级别的生物学、物理学和化学问题上也取得了卓越的成绩。这些结果凸显了强化学习在增强大型语言模型推理能力方面的有效性。

DeepSeek-R1-Zero 的自我进化体现了强化学习如何自主增强模型的推理能力。

如图 1(b) 所示，DeepSeek-R1-Zero 在整个训练过程中思维时间持续增加，这完全是由其内在适应而非外部调整驱动的。凭借较长的思维时间，该模型逐步完善其推理过程，生成数百至数千个 token 来探索和改进其问题解决策略。

思考时间的增加促进了复杂行为的自主发展。具体而言，DeepSeek-R1-Zero 逐渐展现出高级推理策略，例如反思性推理和系统性地探索替代解决方案（详见补充材料 C.2 中的图 9(a)），显著提升了其在数学和编程等可验证任务上的表现。值得注意的是，在训练过程中，DeepSeek-R1-Zero 出现了一个“顿悟时刻”（表 2），其特征是在反思过程中“wai”一词的使用频率突然增加（详见补充材料 C.2 中的图 9(b)）。这一时刻标志着推理模式的显著变化，并清晰地展现了 DeepSeek-R1-Zero 的自我进化过程。

DeepSeek-R1-Zero 的自我演化凸显了强化学习的强大之处和精妙之处：我们无需显式地教会模型如何解决问题，只需提供合适的激励，它就能自主地发展出更高级的问题解决策略。这提醒我们，强化学习拥有巨大的潜力，能够释放低层次模型（LLM）的更高能力，并为未来构建更自主、更具适应性的模型铺平道路。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4cdb6f1b639f4a30b22727e8c3c3d7a9.png)

# 3.DeepSeek-R1

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/8e4958464699473699efc4d80f650884.png)


尽管 DeepSeek-R1-Zero 展现出强大的推理能力，但它也面临一些问题。例如，由于 DeepSeek-V3-Base 是在多种语言（尤其是英语和中文）上训练的，因此 DeepSeek-R1-Zero 在可读性差和语言混合等问题上表现不佳。为了解决这些问题，我们开发了 DeepSeek-R1，其流程如图 2 所示。

在初始阶段，我们收集了数千条冷启动数据，这些数据展现了与人类对话相符的思维过程。随后，我们应用强化学习（RL）训练来提升模型在对话思维过程和语言一致性方面的表现。之后，我们再次应用拒绝采样和 SFT 训练。此阶段将推理和非推理数据集都纳入 SFT 流程，使模型不仅在推理任务中表现出色，而且展现出高级的写作能力。为了进一步使模型与人类偏好保持一致，我们实施了第二个强化学习阶段，旨在增强模型的实用性和安全性，同时提升其推理能力。

本节余下部分详细介绍了该流程的关键组成部分：第 3.1 节介绍了我们在强化学习阶段使用的奖赏模型，第 3.2 节详细阐述了具体的训练方法和实现细节。我们在该阶段使用的数据详见补充材料 B.3。

## 3.1 Model-based Rewards

对于通用数据，我们采用奖赏模型来捕捉复杂细致场景下的人类偏好。我们基于 DeepSeek-V3 流程，并采用类似的偏好对分布和训练提示。为了评估实用性，我们只关注最终的摘要，确保评估结果强调响应对用户的实用性和相关性，同时最大限度地减少对底层推理过程的干扰。为了评估无害性，我们评估模型的整个响应，包括推理过程和摘要，以识别并减轻生成过程中可能出现的任何潜在风险、偏差或有害内容。

**Helpful Reward Model**。为了训练有效的奖赏模型，我们首先使用补充材料 B.2 中列出的 arena-hard 提示格式向 DeepSeek-V3 生成偏好对。其中，每个偏好对包含一个用户 query 和两个候选答案。对于每个偏好对，我们调用 DeepSeek-V3 四次，并将答案随机分配为答案 A 或答案 B，​​以减少位置偏差。最终偏好得分由四次独立判断的平均值确定，仅保留得分差 (Δ) 大于 1 的偏好对，以确保区分的有效性。此外，为了最大限度地减少长度相关的偏差，我们确保整个数据集中被选择和被拒绝的答案长度相当。我们总共整理了 66,000 个数据对用于训练奖赏模型。该数据集中使用的提示均为非推理性问题，来源要么是公开的开源数据集，要么是用户明确同意分享其数据以改进模型。我们的奖赏模型架构与 DeepSeek-R1 的架构一致，增加了一个奖赏头，旨在预测标量偏好分数。

$$Reward_{helpful}=RM_{helpful}(Response_A,Response_B)\tag{5}$$

我们使用 256 的 batch、6e-6 的学习率，在训练数据集上进行单 epoch 训练，来训练这些有用的奖赏模型。训练期间的最大序列长度设置为 8192 个 token，而奖赏模型推理期间则没有设置明确的长度限制。

**Safety Reward Model**。为了评估和改进模型安全性，我们整理了一个包含 106,000 个提示的数据集，这些提示均由模型生成，并根据预定义的安全准则标注为“安全”或“不安全”。与 helpful 奖赏模型中使用的成对损失不同，安全奖励模型采用逐点方法进行训练，以区分安全和不安全的响应。其训练超参数与 helpful 奖励模型相同。

$$Reward_{safety}=RM_{safety}(Response)\tag{6}$$

对于通用问题，每个实例都会被归类为属于安全数据集或有用性数据集。分配给每个 query 的一般奖赏 $Reward_{General}$ 对应于关联数据集中定义的相应奖赏。

## 3.2 Training Details

### 3.2.1 Training Details of the First RL Stage

在强化学习的第一阶段，我们将学习率设置为 3e-6，KL 系数设置为 0.001，GRPO 裁剪率 ε 设置为 10，采样 temperature 设置为 1（针对 rollout）。对于每个问题，我们采样 16 个输出，最大长度为 32,768。每个训练步骤包含 32 个不同的问题，因此每个步骤的训练 batch size 为 512。每 400 步，我们将 ref 模型替换为最新的策略模型。为了加速训练，每次 rollout 生成 8,192 个输出，这些输出被随机分成 16 个小 batch，并仅训练一个内部 epoch。然而，为了缓解语言混合问题，我们在强化学习训练中引入了语言一致性奖赏，该奖赏计算为目标语言词汇在词库 (CoT) 中的比例。

$$Reward_{language}=\frac{Num(Words_{target})}{Num(Words)}\tag{7}$$

尽管补充材料 B.6 中的消融实验表明，这种语言一致性会导致模型性能略微下降，但这种奖励机制符合人类偏好，使其更易于理解。我们将语言一致性奖赏直接添加到最终奖赏中，从而将其应用于推理数据和非推理数据。

请注意，裁剪比例在训练过程中起着至关重要的作用。较低的裁剪比例会导致大量 token 的梯度被截断，从而降低模型的性能；而较高的裁剪比例则可能导致训练过程中的不稳定。

### 3.2.2 Training Details of the Second RL Stage

具体来说，我们结合奖赏信号和多样化的提示分布来训练模型。对于推理数据，我们遵循DeepSeek-R1-Zero中概述的方法，该方法采用基于规则的奖赏来指导数学、编码和逻辑推理领域的学习。在训练过程中，我们观察到 CoT 经常出现语言混合现象，尤其是在强化学习提示涉及多种语言时。对于通用数据，我们利用奖赏模型来指导训练。最终，奖赏信号与多样化数据分布的结合使我们能够开发出一个不仅在推理方面表现出色，而且还优先考虑有用性和无害性的模型。给定一批数据，奖励可以表示为：

$$Reward=Reward_{reasoning}+Reward_{general}+Reward_{language}\tag{8}$$

$$where,~Reward_{reasoning}=Reward_{rule}\tag{9}$$

$$Reward_{general}=Reward_{reward\_model}+Reward_{format}\tag{10}$$

强化学习的第二阶段保留了第一阶段的大部分参数，主要区别在于 temperature 降低至 0.7，因为我们发现该阶段较高的温度会导致生成不一致的指令。该阶段共包含 1700 个训练步骤，其中通用指令数据和基于偏好的奖赏仅在最后 400 个步骤中引入。我们发现，使用基于模型的偏好奖赏信号进行更多训练步骤可能会导致reward hacking ，这在补充材料 B.5 中有详细记录。总训练成本列于补充材料 B.4.4。

# 4.实验

# Appendix

## A.Background

### A.1 DeepSeek-V3

### A.2 Conventional Post-Training Paradigm

### A.3 A Comparison of GRPO and PPO

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/30cf102674ac45efa9d981a7bc92317c.png)

我们采用组相对策略优化（GRPO）来训练 DeepSeek-R1-Zero 和 DeepSeek-R1。GRPO 最初是为了简化训练过程并降低近端策略优化（PPO）的资源消耗而提出的，PPO 广泛应用于 LLM 的强化学习阶段。GRPO和PPO的总体比较见图3。

对于每个问题 $q$，GRPO 从旧策略 $\pi_{\theta_{old}}$ 中抽取一组输出 $\{o_1, o_2, · · · , o_G\}$，然后通过最大化以下目标来优化策略模型 $\pi_{\theta}$：

$$\begin{array}{cc}
\mathcal J_{GRPO}(\theta)=\mathbb E[q\sim P(Q),\{o_i\}^G_{i=1}\sim\pi_{\theta_{old}}(O|q)]\\
\frac{1}{G}\sum^G_{i=1}(min(\frac{\pi_{\theta}(o_i|q)}{\pi_{\theta_{old}}(o_i|q)}A_i, \frac{\pi_{\theta}(o_i|q)}{\pi_{\theta_{old}}(o_i|q)},1-𝜀, 1+𝜀)A_i)-\beta\mathbb D_{KL}(\pi_{\theta}||\pi_{ref})),
\end{array}\tag{11}$$

$$\mathbb D_{KL}(\pi_{\theta}||\pi_{ref})=\frac{\pi_{ref}(o_i|q)}{\pi_{\theta}(o_i|q)}-log\frac{\pi_{ref}(o_i|q)}{\pi_{\theta}(o_i|q)}-1,\tag{12}$$

其中 $\pi_{ref}$ 是参考策略，$𝜀$ 和 $𝛽$ 是超参数，$A_i$ 是优势函数，使用一组奖赏 $\{r_1,r_2, . . . ,r_G\}$ 计算得出，这些奖赏对应于每个组内的输出：

$$A_i=\frac{r_i-mean(\{r_1,r_2,...,r_G\})}{std(\{r_1,r_2,...,r_G\})}.\tag{13}$$

相比之下，在近端策略优化算法（PPO）中，优势函数通常是通过应用广义优势估计（GAE）来计算的，该估计不仅基于奖赏，还基于一个学习到的 value 模型。由于 value 模型通常与策略模型规模相近，因此会引入显著的内存和计算开销。此外，value 模型的训练目标是基于从初始状态到当前状态生成的 token，预测从当前状态开始的期望累积奖赏。这本身就非常困难，尤其是在只有最终结果奖赏可用的情况下。当训练长链推理模型时，挑战会更加突出。**随着输出长度的增加，模型在生成过程中更有可能进行反思和修正等行为，这意味着最初生成的内容之后可能会被修正或推翻，这使得基于部分响应预测最终奖赏变得更加困难。**

GRPO 和 PPO 的另一个关键区别在于训练过程中 Kullback-Leibler (KL) 散度的纳入方式。在 GRPO 中，如公式 11 所示，KL 散度的无偏估计量直接添加到损失函数中；**而在 PPO 中，每个 token 的 KL 惩罚作为密集奖赏添加到每个 token**。由于强化学习的优化目标是最大化累积奖赏，PPO 的方法会惩罚累积 KL 散度，这可能会隐式地惩罚响应的长度，从而阻止模型响应长度的增加。此外，在训练长链推理模型时，我们可能需要训练数千步，因此训练后的策略可能与初始参考策略存在显著偏差。为了平衡训练策略的探索范围和训练的稳定性，我们在实际训练过程中会定期将参考策略更新为最新策略。

图 4 比较了 PPO 和 GRPO 在 MATH 任务上的性能，测试模型为 DeepSeek-Coder-V2-Lite（16B MoE，2.4B 个激活参数）。与 GRPO 不同，PPO 需要额外的超参数调优，特别是 GAE 中的 𝜆 系数，并且对该参数非常敏感。当 𝜆 设置为 0.95（大多数开源 PPO 实现中的默认值）时，PPO 的性能远逊于 GRPO。然而，通过仔细调优（将 𝜆 设置为 1.0），PPO 的性能显著提升，接近 GRPO 的水平。

虽然 PPO 在适当调优后可以达到类似的性能，但它需要额外的计算成本来进行超参数优化。此外，考虑到训练额外 value 模型所带来的内存和计算开销，GRPO 提供了一种更实用的替代方案，尤其是在资源受限的情况下训练大规模模型时。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a0bcf0c47cba406784336caee829e574.png)
