论文链接：https://arxiv.org/pdf/2602.02276

代码链接：https://huggingface.co/moonshotai/Kimi-K2.5

# 摘要

我们推出了 Kimi K2.5，这是一个开源的多模态 Agent 模型，旨在提升通用智能体的性能。K2.5 强调文本和视觉的联合优化，使两种模态相互增强。这包括一系列技术，例如联合文本-视觉预训练、零视觉 SFT 和联合文本-视觉强化学习。基于这种多模态基础，K2.5 引入了 Agent Swarm，这是一个自导向的并行智能体编排框架，能够动态地将复杂任务分解为异构子问题并并行执行。大量的评估表明，Kimi K2.5 在编码、视觉、推理和智能体任务等多个领域均取得了最先进的成果。与单智能体基线模型相比，Agent Swarm 还将延迟降低了高达 4.5 倍。我们发布了经过后训练的 Kimi K2.5 模型 checkpoint，以促进智能体的未来研究和实际应用。

# 1.介绍

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2334f04a83da41e1a27a5f14454c449d.png)

大语言模型（LLM）正迅速向智能体方向发展。近期的一些成果，例如 GPT-5.2、Claude Opus 4.5、Gemini 3 Pro 和 Kimi K2-Thinking，都展现了智能体能力的显著提升，尤其是在工具调用和推理方面。这些模型越来越能够将复杂问题分解为多步骤计划，并执行交替的长序列推理和动作。

在本报告中，我们介绍了 Kimi K2.5 的训练方法和评估结果。具体而言，我们在以下两个关键方面改进了 K2.5 相对于先前模型的训练。

**Joint Optimization of Text and Vision**。K2.5 实践中的一个关键启示是，文本和视觉的联合优化能够增强两种模态的性能并避免冲突。具体而言，我们为此设计了一系列技术。在预训练阶段，与传统方法在后期将视觉 token 添加到文本骨架中不同，我们发现，在视觉-文本 token 预算固定的情况下，早期以较低比例进行视觉融合往往能获得更好的结果。因此，K2.5 在整个训练过程中以恒定比例混合文本和视觉 token。

在架构上，Kimi K2.5 采用了 MoonViT-3D，这是一种原生分辨率视觉编码器，它结合了 NaViT 打包策略，从而能够处理可变分辨率的图像输入。为了实现视频理解，我们引入了一种轻量级的 3D ViT 压缩机制：将连续帧以四帧为一组，通过共享的 MoonViT 编码器进行处理，并在图像块级别进行时间平均。这种设计使得 Kimi K2.5 能够在相同的上下文窗口内处理时长最多可达 4 倍的视频，同时保持图像编码器和视频编码器之间完全的权重共享。

在后训练阶段，我们引入了零视觉 SFT——仅文本 SFT 即可激活视觉推理和工具使用。我们发现，在此阶段添加人工设计的视觉轨迹会损害泛化能力。相比之下，仅文本 SFT 表现更佳——这可能是因为联合预训练已经建立了强大的视觉-文本对齐能力，从而使模型能够自然地跨模态泛化。随后，我们将联合强化学习应用于文本和视觉任务。**至关重要的是，我们发现视觉强化学习提升了文本任务的性能，而非降低其性能**，在 MMLU-Pro 和 GPQADiamond 任务上均取得了改进。这种双向增强——文本引导视觉，视觉优化文本——体现了联合训练中卓越的跨模态对齐能力。

**Agent Swarm: Parallel Agent Orchestration**。大多数现有的智能体模型依赖于工具调用的顺序执行。即使是像 Kimi K2-Thinking 这样能够进行数百步推理的系统，也存在推理时间线性扩展的问题，导致不可接受的延迟并限制了任务的复杂性。随着智能体工作负载的范围和异构性不断增加——例如，构建涉及大规模研究、设计和开发的复杂项目——这种顺序执行模式的效率会越来越低。

为了克服智能体顺序执行的延迟和可扩展性限制，Kimi K2.5 引入了 Agent Swarm，这是一个用于并行智能体编排的动态框架。我们提出了一种 Parallel-Agent Reinforcement Learning (PARL) 范式，它不同于传统的智能体强化学习。除了通过可验证的奖赏来优化工具执行之外，该模型还配备了用于创建子智能体和任务委派的接口。在训练过程中，子智能体被冻结，它们的执行轨迹不参与优化目标；只有 orchestrator 通过强化学习进行更新。**这种解耦规避了端到端协同优化的两个挑战：信用分配的不确定性和训练的不稳定性**。Agent Swarm 能够将复杂任务分解为异构子问题，并由特定领域专业的智能体并发执行，从而将任务复杂度从线性扩展转变为并行处理。在广泛搜索场景中，与单智能体基线相比，Agent Swarm 可以将推理延迟降低高达 4.5 倍，同时将项目级 F1 值从 72.8% 提高到 79.0%。

Kimi K2.5 代表了一种通用智能体的统一架构，它集成了视觉和语言、思维模式和即时模式、聊天和 Agent 功能。在广泛的智能体和前沿基准测试中，它均取得了优异的性能，包括在我们内部评估中视觉到代码生成（图像/视频到代码）和实际软件工程方面取得的领先成果，同时还能扩展专用 Agent 的多样性和并行度。为了加速社区在通用智能体领域的发展，我们开源了 Kimi K2.5 的后训练 checkpoint，使研究人员和开发人员能够探索、改进和部署可扩展的智能体。

# 2.Joint Optimization of Text and Vision

Kimi K2.5 是一个原生多模态模型，它基于 Kimi K2 构建，并利用约 15T 混合视觉和文本 token 进行了大规模联合预训练。与那些牺牲语言或视觉能力的视觉自适应模型不同，我们的联合预训练范式能够同时增强两种模态。本节将介绍将 Kimi K2 扩展到 Kimi K2.5 的多模态联合优化方法。

## 2.1 Native Multimodal Pre-Training
![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/053c5bf14d7f4e3fbe5f87fe0046cc83.png)


多模态预训练的一个关键设计问题是：**在视觉-文本 token 预算固定的情况下，最优的视觉-文本联合训练策略是什么**？传统观点认为，在 LLM 训练的后期阶段，以较高的比例（例如50%或更高）引入视觉 token，可以加速多模态能力的习得，并将多模态能力视为语言能力的后加部分。

然而，我们的实验（如表 1 和图 9 所示）揭示了不同的结果。我们进行了消融实验，在保持视觉和文本 token 总数不变的情况下，改变了视觉比例和视觉注入时间。为了严格达到不同比例的目标，我们在引入视觉数据之前，使用特定数量的纯文本 token 对模型进行预训练。**出乎意料的是，我们发现视觉比例对最终的多模态性能影响甚微。事实上，在视觉-文本 token 总数固定的情况下，使用较低的视觉比例进行早期融合反而能获得更好的结果**。这促使我们提出了一种原生的多模态预训练策略：我们并非在训练后期集中进行高强度的视觉数据训练，而是在训练过程早期就采用适中的视觉比例，使模型能够自然地发展出平衡的多模态表征，同时受益于两种模态的协同优化。

## 2.2  Zero-Vision SFT

预训练的视觉语言模型（VLM）无法自然地执行基于视觉的工具调用，这给多模态强化学习带来了冷启动问题。传统方法通过人工标注或提示设计的思维链（CoT）数据来解决这个问题，但这些方法的多样性有限，通常将视觉推理限制在简单的图表和原始的工具操作（裁剪、旋转、翻转）上。

观察发现，高质量的文本 SFT 数据相对丰富且多样化。我们提出了一种新的方法——零视觉SFT，该方法仅使用文本SFT数据在训练后激活视觉和智能体能力。**在这种方法中，所有图像处理都通过 IPython 中的程序化操作来实现，有效地泛化了传统视觉工具的使用方式**。这种“零视觉”激活能够实现多种推理行为，包括像素级操作，例如通过二值化和计数来估计物体大小，并且可以泛化到基于视觉的任务，例如物体定位、计数和OCR。

图 2 展示了强化学习 (RL) 的训练曲线，其初始点来自零视觉 SFT。结果表明，零视觉 SFT 足以激活视觉能力，同时确保跨模态泛化。这种现象很可能是由于 2.1 节中描述的文本和视觉数据的联合预训练所致。与零视觉 SFT 相比，我们的初步实验表明，文本-视觉 SFT 在视觉和智能体任务上的表现要差得多，这可能是由于缺乏高质量的视觉数据。

## 2.3 Joint Multimodal Reinforcement Learning (RL)

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/dd9ecf5d63f54dc5a06a06968bb62f8e.png)

在本节中，我们将介绍 K2.5 中实现的有效多模态强化学习方法，从基于结果的视觉强化学习到增强文本性能的新兴跨模态迁移。

**Outcome-Based Visual RL**。在 Zero-Vision SFT 之后，该模型需要进一步改进，才能可靠地将视觉输入融入推理过程。仅由文本触发的激活存在明显的缺陷：视觉输入有时会被忽略，图像在必要时也可能未被关注。我们针对那些明确需要视觉理解才能获得正确答案的任务，采用基于结果的强化学习。我们将这些任务分为三个领域：
- **Visual grounding and counting**：精确定位和枚举图像中的物体；
- **Chart and document understanding**：结构化视觉信息的解读和文本提取；
- **Vision-critical STEM problems**：筛选出需要视觉输入的数学和科学问题。

在这些任务上，基于结果的强化学习既能提升基本的视觉能力，也能增强更复杂的智能体行为。提取这些轨迹进行拒绝采样微调（RFT）可以构建一个自改进的数据管道，从而使后续的联合强化学习阶段能够利用更丰富的多模态推理轨迹。

**Visual RL Improves Text Performance**。为了探究视觉和文本性能之间潜在的权衡，我们在视觉强化学习前后评估了纯文本基准测试。出乎意料的是，基于结果的视觉强化学习在文本任务中产生了可衡量的提升，包括 MMLU-Pro（84.7% → 86.4%）、GPQA-Diamond（84.3% → 86.4%）和 LongBench v2（56.7% → 58.9%）（表 2）。分析表明，视觉强化学习增强了需要结构化信息提取领域的校准能力，降低了类似于基于视觉推理的查询（例如计数、OCR）的不确定性。这些发现表明，视觉强化学习可以促进跨模态泛化，在不明显降低语言能力的情况下提升文本推理能力。

**Joint Multimodal RL**。受 Zero-Vision SFT 与视觉强化学习相结合能够产生强大的视觉能力这一发现的启发（视觉能力的提升还能进一步增强通用的文本能力），我们在Kimi K2.5的后训练阶段采用了联合多模态强化学习范式。与传统的模态特定专家划分不同，我们并非根据输入模态，而是根据能力（例如知识、推理、编码、自主性等）来组织强化学习领域。这些领域专家共同学习纯文本和多模态查询，而生成式奖赏模型（GRM）则在异构轨迹上进行优化，不受模态限制。这种范式确保了通过文本或视觉输入获得的能力提升能够自然地泛化到另一种模态的相关能力，从而最大限度地提高跨模态能力迁移。

# 3. Agent Swarm

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/4f8df92e859f4fbfa8f4a17e18f481b9.png)

现有基于 Agent 的系统面临的主要挑战在于其依赖于推理和工具调用步骤的顺序执行。虽然这种结构对于较简单、短期任务可能有效，但随着任务复杂性的增加和累积上下文信息的增长，它便会变得力不从心。当任务演变为包含广泛的信息收集和复杂的多分支推理时，顺序系统往往会遇到严重的瓶颈。

单个 Agent 逐个步骤处理的有限能力会导致实际推理深度和工具调用预算耗尽，最终阻碍系统处理更复杂场景的能力。

为了解决这个问题，我们引入了 **Agent Swarm** 和 **Parallel Agent Reinforcement Learning (PARL)**。K2.5 并非像传统方法那样将任务作为推理链执行，也并非依赖预先设定的并行化启发式算法，而是通过动态任务分解、子智能体实例化和并行子任务调度来构建智能体群。重要的是，并行化本身并不具有优势；是否并行化、何时并行化以及如何并行化的决策是通过环境反馈和强化学习驱动的探索来显式学习的。如图 4 所示，性能的提升体现了这种自适应能力，随着协调器在训练过程中不断优化其并行化策略，累积奖赏也平稳增长。

**Architecture and Learning Setup**。PARL 框架采用了一种解耦架构，包含一个可训练的协调器和从固定的中间策略 checkpoint 实例化的冻结子智能体。这种设计刻意避免了端到端的协同优化，从而规避了两个根本性的挑战：信用分配的模糊性和训练的不稳定性。在这种多智能体设置中，基于结果的奖赏本质上是稀疏且噪声较大的；正确的最终答案并不能保证子智能体执行完美无瑕，正如失败并不意味着子智能体普遍存在错误一样。通过冻结子智能体并将其输出视为环境观测值而非可微分的决策点，我们将高层协调逻辑与底层执行能力解耦，从而实现更稳健的收敛。为了提高效率，我们首先使用小规模的子智能体训练协调器，然后再过渡到更大的模型。我们的强化学习框架还支持动态调整子智能体和协调器之间的推理实例比例，从而最大限度地提高集群的资源利用率。

**PARL Reward**。由于独立子智能体执行中固有的延迟、稀疏和非平稳反馈，训练一个可靠的并行协调器极具挑战性。为了解决这个问题，我们将PARL奖励定义为：

$$r_{PARL}(x,y)=\lambda_1\cdot \underbrace{r_{parallel}}_{instantiation~reward}+\lambda_2\cdot \underbrace{r_{finish}}_{sub-agent~finish~rate}+\underbrace{r_{perf}(x,y)}_{task-level~outcome}.$$

性能奖赏 $r_{perf}$ 评估给定任务 $x$ 的解决方案 $y$ 的整体成功率和质量。此外，还有两个辅助奖赏，分别针对并行编排学习中的一个不同挑战。奖赏 $r_{parallel}$ 用于缓解串行崩溃——即协调器默认执行单 Agent 的局部最优解。通过激励子 Agent 实例化，该奖赏鼓励探索并发调度空间。奖励 $r_{finish}$ 关注已分配子任务的成功完成情况。它用于防止虚假并行性，即协调器通过生成大量子智能体而没有进行有效的任务分解，从而大幅提高并行指标。通过奖赏已完成的子任务，$r_{finish}$ 确保了可行性，并引导策略朝着有效且合理的任务分解方向发展。

为了确保最终策略能够优化主要目标，超参数 $λ_1$ 和 $λ_2$ 在训练过程中逐渐退火至零。

**Critical Steps as Resource Constraint**。为了衡量并行 Agent 环境下的计算时间成本，我们类比计算图中的关键路径来定义关键步骤。我们**将一个回合建模为一系列执行阶段**，索引为 $t = 1,...,T$。在每个阶段，主 Agent 执行一个动作，该动作对应于直接调用工具或实例化一组并行运行的子 Agent。令 $S^{(t)}_{main}$ 表示主 Agent 在阶段 $t$ 执行的步骤数（通常 $S^{(t)}_{main} = 1$），$S^{(t)}_{sub,i}$ 表示该并行组中第 i 个子 Agent 执行的步骤数。阶段 $t$ 的持续时间取决于该组子 Agent 中运行时间最长的子 Agent。因此，一个回合的总关键步骤数定义为：

$$CriticalSteps=\sum^T_{t=1}(S^{(t)}_{main}+max_iS^{(t)}_{sub,i}).$$

该框架通过限制训练和评估过程中的关键步骤而非总步骤数，明确地激励了有效的并行化。过度创建子任务（如果不能减少并行组的最大执行时间）在该指标下几乎没有益处，而均衡的任务分解（能够直接缩短最长的并行分支）则可以减少关键步骤。因此，该框架鼓励协调器在子 Agent 之间分配工作，以最大限度地减少端到端延迟，而不是仅仅最大化并发数或总工作量。

**Prompt Construction for Parallel-agent Capability Induction**。为了激励协调器利用并行化的优势，我们构建了一系列合成提示，旨在凸显顺序智能体执行的局限性。这些提示强调两种搜索方式：一种是广度搜索，需要同时探索多个独立的信息源；另一种是深度搜索，需要多个推理分支并进行延迟聚合。此外，我们还加入了受真实世界工作负载启发的任务，例如长上下文文档分析和大规模文件下载。如果顺序执行这些任务，则很难在固定的推理步骤和工具调用预算内完成。通过精心设计，这些提示鼓励协调器并行分配子任务，从而能够在比单个顺序智能体更少的关键步骤内完成任务。重要的是，这些提示并没有明确指示模型进行并行化。相反，它们通过调整任务分布，自然而然地优先采用并行分解和调度策略。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/c71b0d80a51342009501d84b0e4f30e9.png)

# 4.Method Overview

## 4.1 Foundation: Kimi K2 Base Model

Kimi K2.5 的基础是 Kimi K2，这是一个万亿参数的混合专家 (MoE) Transformer 模型，已在 15 万亿个高质量文本 token 上进行预训练。Kimi K2 采用 token 高效的 MuonClip 优化器，并结合 QK-Clip 以保证训练稳定性。该模型总共包含 1.04 万亿个参数，其中 32B 个参数被激活，使用了 384 个专家，每个 token 激活 8 个专家（稀疏度为 48）。有关 MuonClip、架构设计和训练基础设施的详细描述，请参阅 Kimi K2 技术报告。

## 4.2 Model Architecture

Kimi K2.5 的多模态架构由三个组件构成：3D 原生分辨率视觉编码器 (MoonViT-3D)、MLP 投影层 和 Kimi K2 MoE 语言模型，遵循 Kimi-VL 中确立的设计原则。

**MoonViT-3D: Shared Embedding Space for Images and Videos**。在 Kimi-VL 中，我们采用 MoonViT 以原始分辨率对图像进行原生处理，无需复杂的子图像分割和拼接操作。MoonViT 源自 SigLIP-SO-400M，并融合了 NaViT 的图像块打包策略。该策略将单幅图像分割成图像块，展平后按顺序拼接成一维序列，从而能够高效地同时训练不同分辨率的图像。

为了最大限度地将图像理解能力迁移到视频，我们引入了 MoonViT-3D，它采用统一的架构、完全共享的参数和一致的嵌入空间。通过将“patch n’ pack”理念推广到时间维度，最多连续的四个帧被视为一个时空体：来自这些帧的二维图像块被联合展平并打包成一个一维序列，从而使相同的注意力机制能够在空间和时间上无缝运行。额外的时间注意力增强了对高速运动和视觉特效的理解，而这种共享则最大限度地提高了从静态图像到动态视频的知识泛化能力，从而在无需专门的视频模块或架构分叉的情况下实现了强大的视频理解性能（见表 4）。在多层感知器 (MLP) 投影层之前，轻量级的时间池化将每个时间块内的图像块聚合起来，从而实现 4 倍的时间压缩，显著延长了视频的有效长度。最终形成了一个统一的流程，其中从图像预训练中获得的知识和能力通过一个共享的参数空间和特征表示整体地迁移到视频中。

## 4.3 Pre-training Pipeline

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/806f08001f2244eaa4a2a4900ef77d6b.png)

如表 3 所示，Kimi K2.5 的预训练建立在 Kimi K2 语言模型 checkpoint 的基础上，分三个阶段处理约 15T 个token：首先，进行独立的 ViT 训练，以建立一个强大的原生分辨率视觉编码器；其次，进行联合预训练，以同时增强语言和多模态能力；第三，在高质量数据和长上下文激活上进行中期训练，以完善能力并扩展上下文窗口。

**ViT Training Stage**。MoonViT-3D 持续在 SigLIP 数据集上进行预训练，训练数据集为图像-文本和视频-文本对。其中，文本组件包含多种目标：图像替代文本、图像和视频的合成标题、边界框以及 OCR 文本。与 Kimi-VL 的实现不同，这种持续预训练不包含对比损失，而是仅使用交叉熵损失 $L_{caption}$ 来生成基于输入图像和视频的标题。我们采用两阶段对齐策略。在第一阶段，我们更新 MoonViT-3D，使其通过 caption 损失与 Moonlight-16B-A3B 对齐，此阶段消耗约 1T 个 token，但训练浮点运算次数 (FLOP) 非常少。该阶段使 MoonViT-3D 能够主要理解高分辨率图像和视频。随后是极短的第二阶段，仅更新 MLP 投影层，以将 ViT 与 1T LLM 连接起来，从而实现更平滑的联合预训练。

**Joint Training Stages**。联合预训练阶段从接近完成的 Kimi K2 checkpoint 出发，使用额外的 15T 个视觉文本 token，序列长度为 4K。数据配方通过引入独特的 token、调整数据比例（增加编码相关内容的权重）以及控制每个数据源的最大训练轮数，扩展了 Kimi K2 的预训练分布。第三阶段使用集成的高质量中期训练数据执行长上下文激活，并通过 YaRN 插值逐步扩展上下文长度。这显著提高了长上下文文本理解和长视频理解的泛化能力。

## 4.4 Post-Training

### 4.4.1 Supervised Fine-Tuning

基于 Kimi K2 建立的 SFT 流程，我们开发了 K2.5，该模型通过合成来自 K2、K2 Thinking 以及一系列自主研发的专家模型的高质量候选响应来实现。我们的数据生成策略采用了针对特定领域定制的专用流程，将人工标注与先进的提示工程和多阶段验证相结合。这种方法生成了一个大规模的指令微调数据集，其中包含各种提示和复杂的推理轨迹，最终训练模型优先处理交互式推理，并针对复杂的实际应用进行精确的工具调用。

### 4.4.2 Reinforcement Learning

强化学习是我们后训练阶段的关键环节。为了促进跨文本和视觉模态的联合优化，并使 PARL 能够应用于智能体群，我们开发了一个统一的智能体强化学习环境（附录D），并对强化学习算法进行了优化。文本-视觉联合强化学习和 PARL 均基于本节所述的算法构建。

**Policy Optimization**。对于从数据集 $\mathcal D$ 中抽取的每个问题 $x$，使用先前的策略 $π_{old}$ 生成 $K$ 个响应 $\{y_1,...,y_K\}$。我们针对以下目标优化模型 $π_θ$：

$$L_{RL}(\theta)=\mathbb E_{x\in\mathcal D}[\frac{1}{N}\sum^K_{j=1}\sum^{|y_i|}_{i=1}Clip(\frac{\pi_{\theta}(y^i_j|x,y^{0:i}_{j})}{\pi_{old}(y^i_j|x,y^{0:i}_j)},\alpha,\beta)(r(x,y_j)-\bar r(x))-\tau(log\frac{\pi_{\theta}(y^i_j|x,y^{0:i}_j)}{\pi_{old}(y^i_j|x,y^{(0:i)}_j)})^2].\tag{1}$$

这里 $α, β, τ > 0$ 是超参数，$y_j^{0:i}$ 是第 $j$ 个响应的第 $i$ 个 token 的前缀，$N=\sum^K_{i=1}|y_i|$ 是一个 batch 中生成的 token 的总数，$\bar r(x) = \frac{1}{K}\sum^K_{j=1}r(x,y_j)$ 是所有生成响应的平均奖赏。

该损失函数与 K1.5 中使用的策略优化算法有所不同，它引入了一种基于 token 的裁剪机制，旨在缓解训练框架和推理框架差异所放大的离策略偏差。该机制类似于简单的梯度掩码方案：对对数比在区间 $[α,β]$ 内的 token 正常计算策略梯度，而对超出此范围的 token 的梯度则置零。值得注意的是，与标准 PPO 裁剪的关键区别在于，我们的方法严格依赖于对数比来显式地限制离策略漂移，而与优势的正负无关。这种方法与近期提出的用于稳定大规模强化学习训练的策略相一致。经验表明，该机制对于在需要长时程、多步骤工具使用推理的复杂领域中维持训练稳定性至关重要。我们使用 MuonClip 优化器来最小化该目标函数。

**Reward Function**。对于具有可验证解决方案的任务（例如推理和智能体任务），我们采用基于规则的结果奖赏。为了优化资源消耗，我们还引入了旨在提高 token 效率的预算控制奖赏。对于通用任务，我们采用生成式奖赏模型 (GRM)，该模型提供与 Kimi 内部价值标准一致的细粒度评估。此外，对于视觉任务，我们设计了特定任务的奖赏函数，以提供细粒度的监督。对于视觉定位和点定位任务，我们采用基于 F1 的软匹配奖赏：定位任务从交并比 (IoU) 导出软匹配，而点定位任务在最优匹配条件下从高斯加权距离导出软匹配。对于多边形分割任务，我们将预测的多边形栅格化为二值掩码，并计算分割结果与真实掩码的 IoU 以分配奖赏。对于 OCR 任务，我们采用归一化编辑距离来量化预测结果与真实结果之间的字符级对齐程度。对于计数任务，奖赏根据预测值与真实值之间的绝对差值分配。此外，我们合成了复杂的视觉谜题问题，并利用LLM验证器（Kimi K2）提供反馈。

**Generative Reward Models**。Kimi K2 利用自我评价标准奖赏机制来鼓励开放式生成，而 K2.5 则在此基础上，系统地将生成式奖赏模型 (GRM) 应用于广泛的智能体行为和多模态轨迹。**我们并未将奖赏建模局限于对话输出，而是将 GRM 应用于经过验证的奖赏信号之上，并应用于包括聊天助手、编码智能体、搜索智能体和工件生成智能体在内的各种环境中**。值得注意的是，GRM 并非简单的二元评判器，而是与 Kimi 的用户体验关键价值观相一致的细粒度评估器，这些价值观包括：实用性、响应准备度、上下文相关性、适当的细节水平、生成工件的美观性以及对指令的严格遵循。这种设计使得奖赏信号能够捕捉到细微的偏好梯度，而这些梯度难以用纯粹基于规则或特定任务的验证器进行编码。**为了减轻奖赏作弊和过度拟合单一偏好信号，我们采用了针对不同任务情境量身定制的多个替代 GRM 规则**。

**Token Efficient Reinforcement Learning**。对于具有测试时扩展能力的 LLM 而言，token 效率至关重要。虽然测试时扩展本质上是以计算量换取推理质量，但实际的收益需要算法创新来积极应对这种权衡。我们之前的研究表明，施加与问题相关的预算可以有效地限制推理时的计算量，从而激励模型生成更简洁的思维链推理模式，避免不必要的 token 扩展。**然而，我们也观察到长度过拟合现象：在严格的预算约束下训练的模型通常无法泛化到更高的计算规模**。因此，它们无法有效地利用额外的推理时 token 来解决复杂问题，而是默认使用截断的推理模式。

为此，我们提出 **Toggle**，一种在**推理时 scaling** 与 **预算受限优化**之间交替进行的训练启发式方法。对于第 $t$ 次学习迭代，其奖赏函数定义为：

$$\tilde{r}(x, y)=
\begin{cases}
r(x, y)\cdot \mathbb{I}\{\frac{1}{K}\sum_{i=1}^{K} r(x, y_i)<\lambda \ \text{or}\ |y_i|\le \text{budget}(x)\}
& \text{if } \left\lfloor \tfrac{t}{m} \right\rfloor \ (\text{mod } 2)=0 \ \text{(Phase0)} \\
r(x, y) & \text{if} \left\lfloor \tfrac{t}{m} \right\rfloor \ (\text{mod } 2)=1 \ \text{(Phase1)} .
\end{cases}$$

其中，$\lambda$ 和 $m$ 是算法的超参数，$K$ 表示每个问题的 rollout 数量。具体而言，该算法每经过 $m$ 次迭代就在两个优化阶段之间进行一次切换：

* **Phase0（预算受限阶段，budget limited phase）**：模型被训练在一个**与任务相关的 token 预算**内完成问题求解。为了避免为了效率而过早牺牲质量，该约束是**条件性施加的**：仅当模型在某一问题上的**平均准确率**超过阈值 $\lambda$ 时，才会强制执行该预算约束。

* **Phase1（标准 scaling 阶段，standard scaling phase）**：模型允许生成直到**最大 token 上限**的响应，从而鼓励模型利用更多计算资源，以获得更好的**推理时 scaling**能力。

问题相关的预算通过**正确回答子集中的 token 长度的第 $p$ 个百分位数**来估计：

$$\text{budget}(x)=\text{Percentile}\left(\{|y_j|\ \middle|\ r(x,y_i)=1,\ i=1,\ldots,K\}, p\right).
\tag{2}$$

该预算在训练开始时估计一次，并在之后保持固定不变。值得注意的是，**Toggle** 本质上是一种用于**双目标问题**的随机交替优化方法，其设计目标在于**协调模型的推理能力与计算效率**之间的矛盾。

我们在 **K2 Thinking** 上评估了 Toggle 的有效性。如图 5 所示，我们观察到在几乎所有基准任务上，输出长度均出现了**一致性的下降**。平均而言，Toggle 在**性能几乎不受影响**的情况下，将输出 token 数量减少了 **25~30%**。此外，我们还观察到，思维链（chain-of-thought）中的冗余模式（例如重复验证和机械式计算）显著减少。进一步地，Toggle 展现出**强大的领域泛化能力**。例如，即便仅在数学和编程任务上进行训练，该模型在 **GPQA** 和 **MMLU-Pro** 上依然实现了稳定的 token 减少，而性能退化仅为边际水平（见图 5）。

## 4.5 Training Infrastructure

Kimi K2.5 继承了 Kimi K2 的训练架构，仅做了少量修改。对于多模态训练，我们提出了一种解耦编码器处理方法，将视觉编码器集成到现有流程中，几乎不增加额外开销。

### 4.5.1 Decoupled Encoder Process (DEP)

# 5.Evaluations
