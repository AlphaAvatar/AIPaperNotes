论文链接：https://arxiv.org/pdf/2506.21545

代码链接：https://github.com/microsoft/DELT

# 摘要

数据是语言模型 (LM) 训练的基础。近期的研究致力于数据效率，旨在通过选择最小或最优的训练数据子集来最大化性能。数据过滤、采样和选择等技术在这一领域发挥着至关重要的作用。为了补充数据效率，我们定义了“**Data Efficacy**”，它侧重于通过优化**训练数据的组织**来最大化性能，目前这一领域仍未得到充分探索。本文提出了一个通用范式 DELT，用于在语言模型训练中考虑数据效能，并强调了训练数据组织的重要性。DELT 包含三个部分：数据评分、数据选择和数据排序。数据评分根据每个数据样本的属性（例如质量、难度和可学习性）为其分配分数。数据选择根据分数从原始训练数据中选择性地选择一个子集。数据排序利用这些分数以新的、优化的顺序组织训练数据，而不是传统的随机打乱。此外，我们设计了可学习性质量评分 (LQS) 作为数据评分的新实例，它从**梯度一致性**的角度考虑每个数据样本的可学习性和质量。我们还设计了折叠排序 (FO) 作为数据排序的新实例，它解决了模型遗忘和数据分布偏差等问题。全面的实验验证了 Data Efficacy 在 LM 训练中的应用，结果表明：首先，不同的 DELT 实例在不增加数据规模和模型大小的情况下，不同程度地提高了 LM 性能。其次，在这些实例中，我们提出的用于数据评分的 LQS 和用于数据排序的 FO 的组合实现了最显著的改进。最后，通过应用数据选择，数据功效可以与数据效率同时实现。因此，我们相信数据功效是 LM 训练中一个很有前途的基础领域。代码现已公开。

# 1.Introduction

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/6e514f32f7844990b1ae2c66b341e750.png)

语言模型在现代计算应用中意义重大。从翻译和情感分析等自然语言处理任务，到自动推理和对话 Agent 等更复杂的应用，语言模型彻底改变了机器理解、生成以及使用自然语言与人类交互的方式。为了赋予语言模型这些能力，数据是其训练的核心，也是模型基于语言模式和结构学习知识的基础。因此，细致的数据管理对于确保模型在各种应用中始终保持高性能至关重要。

因此，最近的研究集中在数据效率上，即选择语料库中最小或质量最高的子集，同时仍然能够产生强劲的结果。然而，一旦选定该子集，每个剩余的样本通常会被同等对待，并且样本输入模型的顺序是随机的。在本文中，我们将**数据效能 (Data Efficacy)**定义为通过优化训练数据的组织来提升模型性能。该领域是对数据效能的补充，目前仍处于早期阶段，其潜力已通过课程学习得到展现，该学习将样本从易到难地输入模型。

在此背景下，我们注意到，由于训练数据集规模庞大但计算能力有限，最新一代语言模型通常只训练几个 epoch，通常只有一个。这些模型与前几代形成了鲜明对比，符合缩放定律，后者训练了许多 epoch，并且经常导致过度拟合。**这与 QQT 的发现一致，该研究表明高质量数据在重复使用后会迅速失去效用**。换句话说，利用大量训练数据和少量 epoch 比依赖高质量数据和大量 epoch 更有效。因此，有效地组织训练数据集对于提高仅使用几个 epoch 训练的语言模型的性能至关重要。

基于此分析，我们提出了一种通用的数据效能范式，该范式无需改变数据集内容和模型架构即可实现效益，几乎无需任何成本。具体而言，该范式包含数据评分、数据选择和数据排序三个部分。数据评分为每个样本分配一个分数，**该分数反映了难度、质量、多样性和可学习性等因素**。数据选择则根据这些分数选择性地选择原始训练数据的子集。数据排序则根据这些分数对训练数据进行组织，可以是升序、降序或其他排列方式。**课程学习可以视为我们范式中的一个具体示例，其根据难度评分进行升序排序**。

为了验证所提出的范式，我们将一些基线方法集成到其中，并分别设计了用于数据评分和排序的新方法。图 1 中的关键结果突出显示，所提出的 DELT 在一系列典型基准上显著提高了语言模型训练的数据效率。同时，它在数据效率方面优于现有方法，从而进一步提升了语言模型在所有选择率下的性能。

本文的主要贡献如下：
- 我们发现了语言模型训练中尚未充分探索的领域——数据效能 (Data Efficacy) 的潜力，并提出了该领域的通用范式 DELT，它由数据评分、数据选择和数据排序组成。
- 我们设计了一种创新的数据评分方法，称为可学习性-质量评分（LQS），它从梯度一致性的角度根据可学习性和质量评估每个数据样本的分数。
- 我们设计了一种新的数据排序方法，称为折叠排序（FO），它可以优化 LM 训练并缓解模型遗忘和数据分布偏差的问题。
- 我们进行了全面的实验，在主流基准测试中验证了 DELT 范式，并采用了不同的数据评分和数据排序方法。所有提出的范式实例都提升了性能，其中我们的设计表现更胜一筹。

通过这些贡献，我们旨在为理解和应用 LM 训练中的数据功效提供一个通用范例，为更有效的模型开发实践铺平道路。

# 2.Related Work

## 2.1 Data Sources

语言模型训练的数据源主要可分为五类：互联网数据、书籍、合成数据、物理传感器和人类对现实世界的感知。互联网数据由于规模庞大而成为语言模型训练的主要来源。书籍和合成数据质量高，但规模有限。来自物理传感器和人类感知的数据处于其他模态或仍在开发中。一些研究专注于提取用于语言模型训练的高质量数据集，例如 C4、RefinedWeb、RedPajama 和 RedStone。它们都使用相同的数据源 CommonCrawl，该数据源捕获不同时期来自整个互联网的网页快照，迄今为止包含超过 2000 亿个样本。

## 2.2 Data Efficiency

数据效率侧重于选择最相关的数据纳入训练数据集，并优化语言模型的性能。**该领域包含一些研究较为深入的策略，例如数据选择、采样、去噪和去重，所有这些策略都旨在选择最优数据以进行高效的模型训练**。KenLM 训练了一个快速且规模较小的模型用于困惑度估计，并将困惑度作为语言模型的数据难度。PDS 通过测量每个样本的梯度方向与参考方向的一致性来评估数据样本的质量。DSIR 开发了一种重要性权重估计器，用于选择一个原始数据子集，该子集能够反映目标在特定特征空间中的分布。 MATES 提出了一种数据影响模型，该模型能够持续适应预训练模型不断变化的数据偏好，并为当前预训练阶段选择最有效的数据。SemDeDup 利用预训练模型的词嵌入来识别并移除语义相似但不完全相同的数据对。所有这些方法都开发了用于决定样本是否应该保留或丢弃的策略。然而，对于保留的样本，语言模型会对其进行相同的训练，而没有考虑标准上的差异。

## 2.3 Data Efficacy

数据效能（与数据效率不同）旨在通过优化训练数据的组织方式来最大化语言模型的性能。如 [11] 所述，课程学习从较简单的示例入手，逐步处理更复杂的示例，从而有助于模型更平滑地收敛。在课程学习中，[36] 提出了一种注意力分数来确定提示的难度，而 [37] 引入了软编辑距离来衡量样本的难度。类似地，如 [3] 所述，退火学习旨在通过首先在一个大型噪声数据集上进行训练，最后使用一个小型高质量数据集来提高模型性能。所有这些方法都直接按难度或质量对训练数据进行排序。然而，由于对数据效能的研究有限，目前还没有一种有效的训练数据组织范式。

总之，数据对于语言模型的训练至关重要，而互联网提供了大量的大规模数据源。然而，由于CommonCrawl 快照增长缓慢以及人工智能生成内容在网络上的日益增多，获取增量式公共数据变得极具挑战性。随着语言模型规模的扩大，有效利用现有数据源变得至关重要，这使得数据效能的重要性日益凸显。尽管如此，鲜有研究关注语言模型训练中的数据效能。为了弥补这一空白，我们提出了一种通用的范式，其中课程学习和退火学习是两个具体实例。

# 3.Paradigm

## 3.1 Problem Formulation

语言模型（LM）由参数 $\textbf θ∈\mathbb R^N$ 表示，该参数可以从头开始预训练，也可以在数据集 $\mathcal D=\{x_n\}^{|D|}_{n=1}$ 上经过 $T$ 次训练后，基于已有的权重进行微调。其中，$N$ 表示 $θ$ 的数量，$x_n$ 表示数据集 $\mathcal D$ 中的第 $n$ 个样本。本文提出的问题旨在通过对下游任务的训练数据集 $\mathcal D$ 进行重新组织来优化 LM 的性能，这在本文中被称为**数据效能（Data Efficacy）**。

## 3.2 Paradigm Definition

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/25b39166353049ce80f2aec14cfd0327.png)

图 2 提出了一种范式，旨在不改变数据内容 $\mathcal D$ 和模型参数 $\textbf θ$ 的情况下，提高语言模型训练中的数据有效性。该范式包含三个组成部分：
- **Data Scoring**：它旨在根据质量、难度、多样性和可学习性等特定标准，为每个训练样本分配一个分数。这些分数随后将用于指导后续阶段的数据选择和数据排序。
- **Data Selection**：它旨在从数据集 $\mathcal D$ 中选择一个最优子集 $\mathcal D^{sub}$，以确保在 $\mathcal D^{sub}$ 上训练的语言模型能够达到最佳性能。此过程会改变数据集 $\mathcal D$ 的大小，但不会影响 $\mathcal D^{sub}$ 的组织结构。
- **Data Ordering**：它的目标是重新组织数据集 D（或 Dsub）中训练样本的顺序，从而创建数据集 D′，使得在 D′ 上训练的语言模型能够获得更优的性能。此过程侧重于数据集 D（或 Dsub）的组织结构，但不会改变数据集的规模。

与直接在原始数据 $\mathcal D$ 上训练语言模型的基线方法以及使用选定子集 $\mathcal D^{sub}$ 的数据效率方法不同，DELT 按如下方式处理原始数据 $\mathcal D$：

首先，数据评分（定义为 $f$）为原始数据 $\mathcal D$ 分配一个得分向量 $γ$，其中 $γ$ 位于一个 $|\mathcal D|$ 维单纯形内。根据评分标准，$γ$ 值较大的样本被认为是良好的。

$$γ=f(\mathcal D)=[γ_1,γ_2,...,γ_{|\mathcal D|}]^T\tag{1}$$

然后，数据选择（记为 $f_s$）根据选择比率 $r$，基于得分 $γ$ 从数据集 $\mathcal D$ 中识别出一个子集 $\mathcal D^{sub}$。待选样本数 $K$ 由 $r$ 决定。函数 $rank$ 提供集合 $γ$ 中每个元素的升序排名索引。

$$\mathcal D^{sub}=f_s(\mathcal D;γ,K)=\{x_k|rank(γ_k)>|\mathcal D|-K~and~1\le k\le|\mathcal D|\}\tag{2}$$
$$K=⌊r · |\mathcal D|⌋\tag{3}$$

最后，数据排序（用 $f_o$ 表示）基于由 $γ$ 确定的排列 $π$，将 $\mathcal D$ 或 $\mathcal D_{sub}$ 重组为大小不变的新数据集 $\mathcal D′$。它可以是 $π_{sort}$，它返回排序后 $γ$ 中每个元素的索引，也可以是其他函数。

$$\mathcal D'=f_o(\mathcal D;γ)=[x_{\pi(γ)_1},x_{\pi(γ)_2},...,x_{\pi(γ)_{|\mathcal D|}}]\tag{4}$$

**Compatibility of data efficacy and data efficiency in DELT**。如图 2 所示，DELT 范式可以在数据评分和数据排序的基础上，通过引入数据选择来进一步提高数据效率。整个 DELT 过程可以定义为将原始数据集 $\mathcal D$ 转换为重新排序的数据集 $\mathcal D′$：

$$\mathcal D'=f_o(γ_o)◦f_s(\mathcal D;γ_s,K),\tag{5}$$

其中符号 $◦$ 表示函数组合。$γ_o$ 和 $γ_s$ 分别是数据排序和数据选择的评分向量。由于数据评分通常需要大量的计算时间，为了方便起见，DELT 中的数据选择和数据排序都使用同一个评分向量，即 $γ_o = γ_s = γ$。这一过程确保选择最合适的样本，并对其进行最优排序，从而显著提高模型在数据有效性和效率方面的性能。

# 4.Method

DELT 范式可以采用多种具体的数据评分和数据排序方法。下文将介绍每种方法的一些基准方法，并提出一种改进方法。这些方法并非穷尽所有方法，其他方法也同样可行。对于数据选择，我们采用 top-k 个数据点的排序方法。

## 4.1 Data Scoring

### 4.1.1 Baseline Method

现有方法通常侧重于质量、难度、噪声或多样性等属性来计算数据选择的分数。

**KenLM** 作为一种小型 n-gram 模型，用于学习训练样本的困惑度，该困惑度被认为可以根据数据样本的难度对其进行评分。

**PDS** 训练了一个紧凑的神经网络来评估数据样本的质量，该质量由每个样本的梯度方向与参考方向的一致性来表示。

然而，这些主要为数据选择而设计的方法，往往只关注样本的质量，而忽略了样本在整个数据集的背景下最有效地贡献于何处的问题。

### 4.1.2 Our Method

为了克服这一局限性，并使评分器更加关注每个数据样本的效用，我们引入了 **Learnability-Quality Scoring (LQS)**。通过结合可学习性和质量，LQS不仅对低质量样本敏感，而且在模型训练过程中更好地权衡了样本的影响。我们的方法通过考虑样本在不同训练阶段的行为，动态评估每个样本对降低下游损失 $J(θ)$ 的贡献。

每个数据样本的**可学习性**代表了模型训练过程中难度的变化，如图 3a 所示。对于从 1 到 T 的训练步骤 $t$，样本 $x_n$ 的可学习性定义为其在训练过程中随时间推移降低损失的能力。可学习性表示为：

$$\mathcal L(x_n)=\sum^{T-1}_{t=1}\frac{l_{n,t}}{l_{n,t+1}}=\sum^{T-1}_{t=1}\frac{||∇ℓ(x_n,\textbf θ_t)||}{∇ℓ(x_n,\textbf θ_{t+1})},\tag{6}$$

其中，$∇ℓ(x_n, \textbf θ_t)$ 表示训练步骤 t 时样本 $x_n$ 的损失函数梯度，$\textbf θ_t$ 为模型参数，$l_{n,t}$ 表示梯度的大小。较高的可学习性得分表明该样本能够显著降低训练损失，尤其是在梯度大小初始较高且随时间大幅下降的情况下。这类样本虽然具有挑战性，但对训练有益，因此更适合用于训练的后期阶段。相反，噪声较大的样本或梯度不稳定的样本具有较低的可学习性得分，这使得在数据选择过程中能够识别并有效过滤掉这些样本。

如图 3b 所示，每个数据样本的**质量**都会影响模型训练过程中的数据有效性。它通过公式 8 中 $∇ℓ(x_n, \textbf θ_t)$ 与目标向量 $λ_{t+1}$ 的一致性来衡量，其中 $λ_{t+1}$ 表示训练步骤 t + 1 时所有数据损失函数的平均梯度。质量得分计算如下：

$$Q(x_n)=\sum^{T-1}_{t=1}cos(\alpha_{n,t})=\sum^{T-1}_{t=1}\frac{\lambda_{t+1}^T∇ℓ(x_n,\textbf θ_t)}{||\lambda_{t+1}||\cdot||∇ℓ(x_n,\textbf θ_t)||},\tag{7}$$

其中 $α_{n,t}$ 表示两个向量之间的夹角。余弦相似度 $cos(α_{n,t})$ 越高，表明 $x_n$ 上的梯度收敛方向与目标向量 $λ_{t+1}$ 越一致，这意味着对降低损失 $J(θ)$ 的贡献越大。如 [10] 中所定义，目标向量 $λ_t$ 为：

$$
\lambda_t =
\begin{cases}
\lambda_{t+1} + \nabla J(\theta_t) - \eta \cdot \nabla^2 L(\theta_t, \gamma) \cdot \lambda_{t+1}, & \text{if}~t < T \\
\nabla J(\theta_t), & \text{if}~t = T
\end{cases}
\tag{8}
$$

最后，我们将**可学习性**（learnability）与**质量**（quality）结合为一个统一的函数，用于对数据样本进行评分。关于公式的详细推导和说明，请参阅附录。评分向量 γ 定义如下：

$$\gamma = \{ \gamma_n | \gamma_n = \sum_{t=1}^{T-1}
\frac{\lambda_{t+1}^\top \nabla \ell(x_n, \theta_t)}
{|\nabla \ell(x_n, \theta_{t+1})|}, 1 \leq n \leq |\mathcal{D}|\}\tag{9}$$

较大的 ( $\gamma_n$ ) 值表示样本具有**更高的质量**，并对**降低下游损失函数 ( $J(\theta)$ )**有显著贡献，尤其是在训练后期阶段引入时。相反，较小的 ( $\gamma_n$ ) 值对应于那些**更容易**、**信息量较少**的样本，它们更适合用于**早期训练阶段**，或者可能是**含噪的样本**，这些样本在数据选择（data selection）场景中可以被过滤掉。有关 LQS（Learnability-Quality Scoring）算法的详细实现，请参阅附录。

## 4.2 Data Ordering

### 4.2.1 Baseline Methods

现有方法通常采用**随机打乱**（shuffling）的方式来组织训练数据。此外，一些方法应用了**课程学习**（curriculum learning） ，它也可被视为一种基于排序的策略。

**随机打乱（Shuffling）方法**随机排列训练数据的顺序，以防止数据分布的不平衡。它作为一种数据组织的基线方法存在，但并未考虑数据的有效性（data efficacy）。

**排序（Sorting）方法**则依据特定的准则（例如数据质量或难度）对训练数据进行排序。置换函数 ( $\pi_{\text{sort}}$ ) 为训练数据中的每个元素提供升序的排名索引。课程学习（curriculum learning）即是此类方法的一个典型例子，它模拟人类学习的过程——从简单样本开始，逐步过渡到更困难的样本。尽管基于排序的方法能够提高训练效果，但它们可能会遭遇诸如模型遗忘（model forgetting）、数据分布偏差（data distribution bias）甚至数据重复（data duplication）等问题，从而影响模型性能。

### 4.2.2 Our Method

我们提出了**折叠学习（Folding method）**，旨在提升训练数据的有效性，并缓解排序方法所带来的负面影响。该新方法称为**折叠学习（folding learning）**，其核心思想是通过**多次重复课程学习过程**，但**不产生数据重复**，从而重新组织数据集。重复的次数定义为折叠层数 ( L )。如图 4 所示，折叠方法在固定的间隔 ( L ) 下，对排序后的数据进行 ( L ) 次无放回采样。置换函数 ( $\pi_{\text{fold}}$ ) 的定义如下（公式 10），而 ( $\pi_{\text{sort}}$ ) 的定义见公式 4。

$$\pi_{\text{fold}}(\gamma; L) =
\bigcup_{\ell=0}^{L-1}
\langle \pi_{\text{sort}}(\gamma)_i \mid i \in { j \mid j \equiv \ell \pmod{L} }, 1 \le j \le |\mathcal{D}| \rangle
\tag{10}$$

折叠学习不仅继承了课程学习的优点，还能有效缓解模型遗忘、数据分布偏差及数据重复等问题。

