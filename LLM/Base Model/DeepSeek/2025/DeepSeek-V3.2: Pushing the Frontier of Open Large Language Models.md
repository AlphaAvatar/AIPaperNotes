论文链接：https://arxiv.org/pdf/2512.02556

代码链接：

# 摘要

我们推出了 DeepSeek-V3.2 模型，该模型兼顾了高计算效率、卓越的推理能力和智能体性能。DeepSeek-V3.2 的关键技术突破如下：(1) **DeepSeek Sparse Attention (DSA)**：我们引入了 DSA，这是一种高效的注意力机制，能够在长上下文场景下显著降低计算复杂度，同时保持模型性能。(2) **Scalable Reinforcement Learning Framework**：通过实现稳健的强化学习协议并扩展后训练的计算能力，DeepSeek-V3.2 的性能与 GPT-5 相当。值得注意的是，我们的高计算量变体 DeepSeek-V3.2-Speciale 的性能超越了 GPT-5，并展现出与 Gemini-3.0-Pro 相当的推理能力，在 2025 年国际数学奥林匹克 (IMO) 和国际信息学奥林匹克 (IOI) 比赛中均荣获金牌。 （3）**Large-Scale Agentic Task Synthesis Pipeline**：为了将推理能力融入工具使用场景，我们开发了一种新型合成流程，能够系统地大规模生成训练数据。该方法有助于实现可扩展的智能体后训练，从而显著提升智能体在复杂交互式环境中的泛化能力和指令执行鲁棒性。

# 1.Introduction

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/777b739bf3ce469d96547266a2202b77.png)

推理模型（DeepSeek-AI, 2025; OpenAI, 2024a）的发布标志着大语言模型（LLM）发展历程中的一个关键时刻，推动了可验证领域整体性能的显著提升。自此里程碑以来，LLM 的能力发展迅猛。然而，近几个月来，出现了明显的分化。尽管开源社区（MiniMax, 2025; MoonShot, 2025; Qwen, 2025; ZhiPu-AI, 2025）持续取得进展，但闭源专有模型（Anthropic, 2025b; DeepMind, 2025a; OpenAI, 2025）的性能提升速度却显著加快。因此，闭源模型和开源模型之间的性能差距非但没有趋于一致，反而似乎正在扩大，专有系统在复杂任务中展现出越来越卓越的能力。

通过分析，我们发现开源模型在复杂任务中的能力存在三个关键缺陷。首先，在**架构**方面，开源模型主要依赖于传统的注意力机制，这严重限制了其处理长序列的效率。这种低效性对可扩展部署和有效的后训练都构成了重大障碍。其次，在**资源分配**方面，开源模型在后训练阶段的计算投入不足，限制了其在复杂任务上的性能。最后，在人工智能 **Agent 领域**，与专有模型相比，开源模型在泛化能力和指令执行能力方面存在显著差距，这阻碍了它们在实际部署中的有效性。

为了解决这些关键限制，我们首先引入了 DSA，一种高效的注意力机制，旨在大幅降低计算复杂度。该架构有效解决了效率瓶颈，即使在长上下文场景下也能保持模型性能。其次，我们开发了一种稳定且可扩展的强化学习协议，允许在后训练阶段进行显著的计算扩展。值得注意的是，该框架分配的后训练计算预算超过预训练成本的 10%，从而解锁了更高级的功能。第三，我们提出了一种新的流程，以促进工具使用场景中的泛化推理。首先，我们利用 DeepSeek-V3 方法实现了一个冷启动阶段，将推理和工具使用统一到单个轨迹中。随后，我们推进到大规模智能体任务合成，生成了超过1800个不同的环境和85000个复杂的提示。这种广泛的合成数据驱动着强化学习过程，显著增强了模型在智能体环境中的泛化能力和指令遵循能力。

DeepSeek-V3.2 在多个推理基准测试中取得了与 Kimi-k2-thinking 和 GPT-5 相近的性能。此外，DeepSeek-V3.2 显著提升了开源模型的智能体能力，在 EvalSys (2025)、Li 等人 (2025) 和 Luo 等人 (2025) 提出的长尾智能体任务上展现出卓越的性能。DeepSeek-V3.2 成为智能体场景中极具成本效益的替代方案，显著缩小了开源模型与前沿专有模型之间的性能差距，同时大幅降低了成本。值得注意的是，为了进一步拓展开源模型在推理领域的应用，我们放宽了长度限制，开发了 DeepSeek-V3.2-Speciale。最终，DeepSeek-V3.2-Speciale 的性能与领先的闭源系统 Gemini-3.0-Pro 达到了相当的水平。它展现了在 2025 年国际象棋大赛 (IOI)、2025 年国际电脑竞技大赛 (ICPC) 世界总决赛、2025 年国际数学奥林匹克 (IMO) 和 2025 年国际数学奥林匹克 (CMO) 中获得金牌的实力。

# 2.DeepSeek-V3.2 Architecture

## 2.1 DeepSeek Sparse Attention

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/2e0dfb90784941b49711f0b75b98786d.png)

DeepSeek-V3.2 使用的架构与 DeepSeek-V3.2-Exp 完全相同。与 DeepSeek-V3.1 的最后一个版本 DeepSeek-V3.1-Terminus 相比，DeepSeek-V3.2 唯一的架构修改是通过持续训练引入 DeepSeek Sparse Attention (DSA)。

**Prototype of DSA**。DSA 原型主要由两个组件构成：**lightning indexer** 和细粒度 token 选择机制。

**lightning indexer** 计算 query token $\textbf h_t ∈ \mathbb R^d$ 与其前一个 token $\textbf h_s ∈ \mathbb R^d$ 之间的索引得分 $I_{t,s}$，从而确定 query token 要选择哪些 token：

$$I_{t,s}=\sum^{H^I}_{j=1}w^I_{t,j}\cdot ReLU(\textbf q^I_{t,j}\cdot \textbf k^I_s),\tag{1}$$

其中，$H^I$ 表示索引器头的数量；$\textbf q^I_{t,j}∈ \mathbb R^{d^I}$ 和 $w^I_{t,j}∈\mathbb R$ 由 query token $\textbf h_t$ 导出；$\textbf k^I_s ∈ \mathbb R^{d^I}$ 由前一个 token $\textbf h_s$ 导出。出于吞吐量的考虑，我们选择 ReLU 作为激活函数。鉴于 lightning indexer 头数较少且可在 FP8 中实现，其计算效率非常显著。

给定每个 query token $\textbf h_t$ 的索引得分 $\{I_{t,s}\}$，我们的细粒度 token 选择机制仅检索与 top-k 个索引得分对应的 key-value 对 $\{\textbf c_s\}$。然后，通过在 query token $\textbf h_t$ 和稀疏选择的 key-value 对 $\{\textbf c_s\}$ 之间应用注意力机制来计算注意力输出 $\textbf u_t$：

$$\textbf u_t=Attn(\textbf h_t,\{\textbf c_s|I_{t,s}\in Top-k(I_{t,:})\}).\tag{2}$$

**Instantiate DSA Under MLA**。为了考虑从 DeepSeekV3.1-Terminus 继续训练，我们基于 MLA 为 DeepSeek-V3.2 实例化了 DSA。在内核层面，为了提高计算效率，每个 key-value 对必须在多个 query 之间共享。因此，我们基于 MLA 的 MQA 模式实现了 DSA （我们在附录 A 中说明了 MLA 的 MQA 模式和 MHA 模式之间的区别），其中每个潜在向量（MLA 的 key-value 对）将在 qeury token 的所有 query 头之间共享。基于 MLA 的 DSA 架构如图 2 所示。我们还提供了 DeepSeek-V3.2 的开源实现，以明确说明细节。

### 2.1.1. Continued Pre-Training

从 DeepSeek-V3.1-Terminus 的基础检查点开始，其上下文长度已扩展到 128K，我们执行继续预训练，然后执行后训练，从而创建 DeepSeekV3.2。

**DeepSeek-V3.2 的持续预训练包含两个训练阶段**。这两个阶段的训练数据分布均与 DeepSeek-V3.1-Terminus 使用的 128K 长上下文扩展数据完全一致。

**Dense Warm-up Stage**。我们首先使用一个简短的预热阶段来初始化  lightning indexer。在此阶段，我们保持密集注意力机制，并冻结除  lightning indexer 之外的所有模型参数。为了使索引器的输出与主注意力分布对齐，对于第 $t$ 个 query token，我们首先聚合所有注意力头的注意力得分。然后，将该总和沿序列维度进行 L1 归一化，以生成目标分布 $p_{t,:} ∈ \mathbb R^t$。基于 $p_{t,:}$，我们将 KL 散度损失设置为索引器的训练目标：

$$\mathcal L^I=\sum_t\mathbb D_{KL}(p_{t,:}||Softmax(I_{t,:})).\tag{3}$$

为了进行预热，我们使用 $10^{−3}$ 的学习率。我们仅训练索引器 1000 步，每步包含 16 个 128K 个 token 的序列，总共得到 2.1 B 个 token。

**Sparse Training Stage**。在索引器预热之后，我们引入细粒度的 token 选择机制，并优化所有模型参数，使模型适应 DSA 的稀疏模式。在此阶段，我们继续将索引器的输出与主注意力分布对齐，但仅考虑选定的 token 集 $\mathcal S_t=\{s|I_{t,s}\in Top-k(I_{t,:})\}$:

$$\mathcal L^I=\sum_t\mathbb D_{KL}(p_{t,\mathcal S_t}||Softmax(I_{t,\mathcal S_t})).\tag{4}$$

值得注意的是，**我们将索引器的输入从计算图中分离出来，以进行单独优化**。索引器的训练信号仅来自 $\mathcal L^I$，而主模型的优化仅基于语言建模损失。在这个稀疏训练阶段，我们使用 $7.3 × 10^{−6}$ 的学习率，并为每个 query token 选择 2048 个 key-value 对。我们对主模型和索引器都进行了 15000 步的训练，每步包含 480 个序列，每个序列包含 128K 个 token，总共得到 943.7B 个 token。

## 2.2. Parity Evaluation

**Standard Benchmark**。2025年9月，我们使用一系列基准测试对 DeepSeek-V3.2-Exp 进行了评估，这些测试涵盖了多种功能，并将其与 DeepSeek-V3.1-Terminus 进行了比较，结果显示两者性能相近。虽然 DeepSeek-V3.2-Exp 在处理长序列时显著提高了计算效率，但在短上下文和长上下文任务中，我们并未观察到其性能较 DeepSeek-V3.1-Terminus 有明显的下降。

**Human Preference**。鉴于直接的人类偏好评估本身就容易受到偏差的影响，我们采用 ChatbotArena 作为间接评估框架，以近似估算用户对新开发的基础模型的偏好。DeepSeek-V3.1-Terminus 和 DeepSeek-V3.2-Exp 采用了相同的后训练策略，并且在 2025 年 11 月 10 日的评估中获得的 Elo 分数也高度吻合。这些结果表明，尽管引入了稀疏注意力机制，新的基础模型仍能达到与前一版本相当的性能。

**Long Context Eval**。在 DeepSeek-V3.2-Exp 发布后，我们使用之前未见过的测试集进行了多次独立的长上下文评估。其中一项代表性基准测试是 AA-LCR3，在该测试中，DeepSeek-V3.2-Exp 在推理模式下的得分比 DeepSeek-V3.1-Terminus 高出 4 分。在 Fiction.liveBench 评估中，DeepSeek-V3.2-Exp 在多个指标上均持续优于 DeepSeek-V3.1-Terminus。这些证据表明，DeepSeek-V3.2-Exp 的基础检查点在长上下文任务上并未出现性能退化。

## 2.3 Inference Costs

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ebe7597ca70647cd94169d0c575f0509.png)

DSA 将主模型的核心注意力复杂度从 $\mathcal O(L^2)$ 降低到 $\mathcal O(Lk)$，其中 $k(≪ L)$ 为选定 token 的数量。虽然 lightning indexer 的复杂度仍然是 $\mathcal O(L^2)$，但与 DeepSeek-V3.1-Terminus 中的 MLA 相比，它所需的计算量要少得多。结合我们优化的实现，DSA 在长上下文场景下实现了显著的端到端加速。图 3 展示了 DeepSeek-V3.1-Terminus 和 DeepSeek-V3.2 的 token 成本如何随 token 在序列中的位置变化。这些成本是通过对部署在 H800 GPU 上的实际服务进行基准测试估算得出的，GPU 的租用价格为每 GPU 小时 2 美元。需要注意的是，对于短序列预填充，我们专门实现了一个掩码 MHA 模式来模拟 DSA，该模式在短上下文条件下可以实现更高的效率。

# 3.Post-Training

经过持续预训练后，我们进行后训练以生成最终的 DeepSeek-V3.2 模型。DeepSeek-V3.2 的后训练也采用了与预训练阶段相同的稀疏注意力机制。对于 DeepSeek-V3.2，我们沿用了与 DeepSeek-V3.2-Exp 相同的后训练流程，其中包括专家蒸馏和混合强化学习训练。

**Specialist Distillation**。针对每项任务，我们首先开发一个专门针对该特定领域的专用模型，所有专用模型均基于同一个预训练的 DeepSeek-V3.2 基准检查点进行微调。除了写作任务和通用问答之外，我们的框架还涵盖六个专业领域：数学、编程、通用逻辑推理、通用智能体任务、智能体编码和智能体搜索，**所有领域均支持思考模式和非思考模式。每个专业模型都使用大规模强化学习 (RL) 计算进行训练**。此外，我们采用不同的模型来生成用于长思维链推理（思考模式）和直接响应生成（非思考模式）的训练数据。专业模型准备就绪后，它们被用于生成最终检查点所需的领域特定数据。实验结果表明，基于蒸馏数据训练的模型性能仅略低于领域特定的专业模型，而后续的强化学习训练可以有效地消除性能差距。

**Mixed RL Training**。对于 DeepSeek-V3.2，我们仍然采用组相对策略优化（GRPO）作为强化学习（RL）训练算法。而对于 DeepSeek-V3.2-Exp，我们将推理、智能体和人类对齐训练合并到一个 RL 阶段。这种方法有效地平衡了不同领域的性能，同时避免了多阶段训练范式中常见的灾难性遗忘问题。对于推理和智能体任务，我们采用基于规则的结果奖励、长度惩罚和语言一致性奖励。对于通用任务，我们采用生成式奖赏模型，其中每个提示都有其自身的评估标准。

**DeepSeek-V3.2 and DeepSeek-V3.2-Speciale**。DeepSeek-V3.2 整合了从专家那里蒸馏出的推理、智能体和人类对齐数据，经过数千步持续强化学习训练，最终达到目标。为了探索扩展思维的潜力，我们还开发了一个实验性变体 DeepSeek-V3.2-Speciale。该模型专门使用推理数据进行训练，并在强化学习过程中采用了缩短长度惩罚。此外，我们还整合了 DeepSeek-Math-V2 的数据集和奖赏方法，以增强其在数学证明方面的能力。

我们将在第 3.1 节重点介绍我们如何创建一个稳定的方法来扩展强化学习计算，以及在第 3.2 节重点介绍如何将思维融入智能体任务中。

## 3.1 Scaling GRPO

我们首先回顾 GRPO 的目标。GRPO 通过最大化以下目标函数来优化策略模型 $\pi_{\theta}$，该目标函数针对从旧策略 $\pi_{old}$ 中抽取的一组响应 $\{o_1, · · · , o_G\}$ 进行优化，给定每个问题 $q$：

$$\mathcal J_{GRPO}(\theta)=\mathbb E_{q\sim P(Q),\{o_i\}^G_{i=1}\sim\pi_{old}(\cdot|q)}\left[\frac{1}{G}\sum^G_{i=1}\frac{1}{|o_i|}\sum^{|o_i|}_{t=1}\\
min(r_{i,t}(\theta)\hat A_{i,t},clip(r_{i,t}(\theta),1-\epsilon,1+\epsilon)\hat A_{i,t})-\beta\mathbb D_{KL}(\pi_{\theta}(o_{i,t}||\pi_{ref}(o_{i,t})))\right],\tag{5}$$

其中

$$r_{i,t}(\theta)=\frac{\pi_{\theta}(o_{i,t}|q,o_{i,\lt t})}{\pi_{old}(o_{i,t}|q,o_{i,<t})}\tag{6}$$

是当前策略与旧策略之间的重要性抽样比率。$ε$ 和 $β$ 分别是控制裁剪范围和 KL 惩罚强度的超参数。$\hat A_{i,t}$ 是 $o_{i,t}$ 的优势，通过对每个组内的结果奖励进行归一化来估计。具体来说，使用一组奖赏模型对组内每个输出 $o_i$ 的结果奖赏 $r_i$ 进行评分，从而分别得到奖励 $\textbf R = \{R_1, · · · , R_G\}$。$o_{i,t}$ 的优势是通过从输出 $o_i$ 的奖赏中减去组的平均奖赏来计算的，即 $\hat A_{i,t} = R_i − mean(\textbf R)$。

接下来，我们将概述一些稳定 RL 扩展的其他策略，这些策略直接建立在 GRPO 算法之上。

**Unbiased KL Estimate**。给定从旧策略 $\pi_{old}(·|q, o_{i,<t})$ 中采样的 $o_{i,t}$，我们使用当前策略 $\pi_{\theta}$ 和旧策略 $\pi_{old}$ 之间的重要性抽样比率来修正 K3 估计器以获得无偏的 KL 估计。

$$\mathbb D_{KL}(\pi_{\theta}(o_{i,t})||\pi_{ref}(o_{i,t}))=\frac{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}{\pi_{old}(o_{i,t}|q,o_{i,<t})}\left(\frac{\pi_{ref}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}-log\frac{\pi_{ref}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}-1\right)\tag{7}$$

由于这种调整，KL 估计器的梯度变​​得无偏，从而消除了系统性估计误差，进而促进了稳定收敛。这与原始的 K3 估计器形成鲜明对比，尤其是在当前策略下采样 token 的概率远低于参考策略下概率时，即 $\pi_{\theta} ≪ \pi_{ref}$。在这种情况下，K3 估计器的梯度会赋予过大且无界的权重以最大化这些 token 的似然性，导致梯度更新噪声过大，累积后会降低后续迭代中的样本质量，并导致训练动态不稳定。**在实践中，我们发现不同领域受益于不同强度的KL正则化。对于某些领域，例如数学，应用相对较弱的KL惩罚甚至完全省略KL惩罚都能获得更好的性能**。

**Off-Policy Sequence Masking**。为了提高强化学习系统的效率，我们通常会生成一大批 rollout 数据，然后将其分割成多个小 batch，用于多次梯度更新。这种做法本身就会引入 off-policy 行为。此外，用于高效生成数据的推理框架通常经过高度优化，其实现细节可能与训练框架有所不同。这种训练-推理的不一致性会进一步加剧 off-policy 行为。为了稳定训练并提高对 off-policy 更新的容忍度，我们对引入显著策略偏差的负序列进行 mask，策略偏差通过数据采样策略 $\pi_{old}$ 和当前策略 $\pi_{\theta}$ 之间的 KL 散度来衡量。更具体地说，我们在 GRPO 损失中引入了一个二值掩码 $M$：

$$\mathcal J_{GRPO}(\theta)=\mathbb E_{q\sim P(Q),\{o_i\}^G_{i=1}\sim\pi_{old}(\cdot|q)}\left[\frac{1}{G}\sum^G_{i=1}\frac{1}{|o_i|}\sum^{|o_i|}_{t=1}\\
min(r_{i,t}(\theta)\hat A_{i,t},clip(r_{i,t}(\theta),1-\epsilon,1+\epsilon)\hat A_{i,t})M_{i,t}-\beta\mathbb D_{KL}(\pi_{\theta}(o_{i,t}||\pi_{ref}(o_{i,t})))\right],\tag{8}$$

其中

$$M_{i,t}=\begin{cases}
0 & \hat A_{i,t}<0,\frac{1}{|o_i|}\sum^{|o_i|}_{t=1}log\frac{\pi_{old}(o_{i,t}|q,o_{i,<t})}{\pi_{\theta}(o_{i,t}|q,o_{i,<t})}>\delta\\
1 & otherwise,
\end{cases}\tag{9}$$

其中，$\dleta$ 是一个超参数，用于控制策略发散的阈值。需要注意的是，$\pi_{old}$ 指的是推理框架直接返回的采样概率，因此旧策略和当前策略之间的 KL 散度可以解释上述两种 off-policy 性来源。此外，值得注意的是，我们仅屏蔽具有负优势的序列。

**直观来看，模型从自身错误中学习获益最大，而高度偏离策略的负样本则可能有害，甚至会误导或破坏优化过程**。我们通过实验观察到，这种偏离策略序列掩码操作可以提高某些原本会表现出不稳定性训练场景的稳定性。

**Keep Routing**。混合专家模型（MoE）通过在推理过程中仅激活部分专家模块来提高计算效率。然而，推理框架和训练框架之间的差异，加上策略更新，即使对于相同的输入，也可能导致推理和训练过程中专家路由的不一致。这种不一致性会引起活动参数子空间的突变，从而破坏优化的稳定性并加剧离策略问题。为了缓解这个问题，我们在推理框架中保留了采样期间使用的专家路由路径，并在训练过程中强制执行相同的路由路径，以确保优化相同的专家参数。这种“保持路由”（Keep Routing）操作对于MoE模型的强化学习（RL）训练稳定性至关重要，并且自DeepSeek-V3-0324版本以来，我们已将其应用于我们的 RL 训练流程中。

**Keep Sampling Mask**。Top-p 和 Top-k 采样是广泛用于提升语言学习模型 (LLM) 生成响应质量的采样策略。在强化学习 (RL) 训练中采用这些策略也很有优势，因为它避免了对极低概率的 token 进行采样，而这些 token 通常会被用作优化目标。虽然这种截断能够保持样本质量，但它会在 $\pi_{old}$ 和 $\pi_{\theta}$ 的动作空间之间引入不匹配，这违反了重要性采样的原则，并导致训练不稳定。为了解决这个问题，我们在从 $\pi_{old}$ 采样时保留截断掩码，并在训练时将其应用于 $\pi_{\theta}$，从而确保两种策略共享相同的动作子空间。实验结果表明，将 Top-p 采样与保留采样掩码 (Keep Sampling Mask) 策略相结合，能够有效地在强化学习训练过程中保持语言一致性。

## 3.2 Thinking in Tool-Use

## 3.2.1 Thinking Context Management

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/815b63045b944520a805028dc0383f42.png)

DeepSeek-R1 已证明，融入思考过程能够显著提升模型解决复杂问题的能力。基于此，我们旨在将思考能力整合到工具调用场景中。

我们观察到，复制 DeepSeek-R1 的策略——即在第二轮消息到达时丢弃推理内容——会导致显著的 token 效率低下。这种方法迫使模型在每次后续工具调用时都重复推理整个问题。为了缓解这个问题，我们开发了一种专门针对工具调用场景的上下文管理机制，如图 4 所示：
- **只有当对话中出现新的用户消息时，历史推理内容才会被丢弃**。如果仅附加与工具相关的消息（例如，工具输出），则推理内容会在整个交互过程中保留。
- 推理痕迹被移除后，工具调用的历史记录及其结果仍保留在上下文中。

值得注意的是，某些 Agent 框架（例如 Roo Code 或 Terminus）通过用户消息模拟工具交互。由于上述上下文管理规则，这些框架可能无法充分利用我们增强的推理持久性。因此，我们建议在此类架构中使用非思维模型以获得最佳性能。

### 3.2.2 Cold-Start

鉴于推理数据（非智能体数据）和非推理智能体数据的可用性，整合这两种能力的一种直接策略是通过精心设计的提示。我们认为，该模型具备足够的能力来准确地遵循明确的指令，从而能够将工具执行无缝地融入推理过程。

为了演示冷启动机制的运行，我们对训练数据进行了选择性采样，如附录表 6-8 所示。需要注意的是，不同的任务提示对应不同的系统提示。表 6-8 展示了一个与竞赛编程提示相对应的示例。表 6 展示了我们的推理数据示例，该数据使用系统提示明确要求模型在给出最终答案之前进行推理，并使用特殊标签 `<think></think>` 来标记推理路径。表 7 展示了非推理智能体数据的提示，其中系统提示包含工具调用的指导。表 8 展示了我们设计的系统提示，该提示指示模型在其推理过程中整合多个工具调用。

这样一来，虽然工具使用模式的推理可能缺乏鲁棒性，但该模型偶尔能够生成所需的轨迹，从而为后续的强化学习阶段提供基础。

### 3.2.3 Large-Scale Agentic Tasks

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/a70f4138cb294afa9b44693cd1b9fb52.png)

多样化的强化学习任务对于增强模型鲁棒性至关重要。对于搜索、代码工程和代码解释等任务，我们使用真实世界的工具，包括实际的网络搜索API、编码工具和Jupyter Notebook。虽然这些强化学习环境是真实的，但所使用的提示要么提取自互联网资源，要么是合成生成的，而不是来自实际的用户交互。对于其他任务，环境和提示都是合成构建的。我们使用的智能体任务如表1所示。

**Search Agent**。我们采用基于 DeepSeek-V3.2 的多智能体流水线来生成多样化的高质量训练数据。首先，我们从大规模网络语料库中采样涵盖不同领域的长尾信息实体。然后，问题构建智能体使用具有可配置深度和广度参数的搜索工具探索每个实体，并将发现的信息整合为问答对。多个具有异构配置（不同检查点、系统提示等）的答案生成智能体为每个提出的问答对生成多样化的候选答案。具有搜索功能的验证智能体通过多次验证来验证所有答案，仅保留真实答案正确且所有候选答案均被验证为错误的样本。这些数据涵盖多种语言、领域和难度级别。为了补充这些可验证的样本并更好地反映真实世界的使用情况，我们还使用来自现有有效强化学习数据集的过滤实例来扩充数据集，这些数据集的搜索工具能够带来显著的提升。然后，我们针对多个质量维度制定详细的评估标准，并采用生成式奖励模型，根据这些标准对回复进行评分。这种混合方法能够兼顾事实可靠性和实用性。

**Code Agent**。我们通过挖掘 GitHub 上数百万个问题-拉取请求 (PR) 对，构建了用于软件问题解决的大规模可执行环境。该数据集经过严格的筛选，采用启发式规则和基于 LLM 的判断，以确保高质量，要求每个条目都包含合理的问题描述、相关的黄金补丁以及用于验证的测试补丁。我们使用基于 DeepSeek-V3.2 的自动化环境搭建 Agent 来为这些 PR 对构建可执行环境。该 Agent 负责软件包安装、依赖关系解析和测试执行。测试结果以标准的 JUnit 格式输出，确保跨编程语言和测试框架的解析一致性。只有当应用 golden 补丁后，假阳性 (F2P) 测试用例数不为零（表明问题已修复）且通过失败 (P2F) 测试用例数为零（表明没有回归）时，环境才被视为构建成功。利用该流程，我们成功构建了数万个可复现的问题解决环境，涵盖多种编程语言，包括 Python、Java、JavaScript、TypeScript、C、C++、Go 和 PHP。

**Code Interpreter Agent**。我们使用 Jupyter Notebook 作为代码解释器来解决复杂的推理任务。为此，我们精心挑选了一系列涵盖数学、逻辑和数据科学领域的问题，每个问题都要求模型利用代码执行功能来得出解决方案。

**General Agent**。为了扩展强化学习中的智能体环境和任务规模，我们采用了一种自动环境合成智能体，该智能体合成了 1827 个面向任务的环境。这些任务虽然难以求解，但易于验证。合成工作流程主要包括环境和工具集构建、任务合成以及解决方案生成。具体而言，工作流程如下。
1. 给定一个任务类别（例如，规划旅行行程）和一个配备 bash 和搜索工具的沙箱，Agent 首先使用这些工具从互联网生成或检索相关数据，并将它们存储在沙箱数据库中。
2. 然后，该 Agent 合成一组特定于任务的工具，每个工具都以函数的形式实现。
3. 为了创建既具有挑战性又可自动验证的任务，智能体首先基于当前数据库提出一个简单的任务，并为其提供用 Python 实现的解决方案和验证函数。解决方案函数仅限于调用工具函数或执行逻辑运算，不能调用其他函数或直接访问数据库，从而确保任务只能通过工具接口解决。此外，解决方案函数产生的结果必须经过验证函数的验证。如果解决方案未通过验证，智能体将修改解决方案或验证函数，直到解决方案的输出通过验证为止。然后，智能体迭代地增加任务难度，并更新相应的解决方案和验证函数。在此迭代过程中，如果当前工具集不足以解决任务，智能体将扩展工具集。

按照此工作流程，我们获得了数千个 <环境、工具、任务、验证器> 元组。然后，我们使用 DeepSeek-V3.2 对该数据集进行强化学习，并仅保留 pass@100 非零的实例，最终得到 1827 个环境及其对应的任务（共 4417 个）。下面展示了一个合成的行程规划示例。该示例表明，虽然在庞大的组合空间中搜索满足所有约束的行程规划方案极具挑战性，但检查给定的候选解决方案是否满足这些约束却相对简单。

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/e86ac625667f4c4889cc308aef70ce2a.png)

# 4.Evaluation
