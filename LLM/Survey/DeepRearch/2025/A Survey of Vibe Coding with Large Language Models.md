论文链接：https://arxiv.org/pdf/2510.12399v1

代码链接：

# 摘要

大语言模型（LLM）的进步推动了辅助代码生成到自主编码 Agent 的范式转变，催生了一种名为“Vibe Coding”的新型开发方法。**在这种方法中，开发者通过观察结果而非逐行理解代码来验证人工智能生成的实现**。尽管Vibe Coding具有变革性的潜力，但其有效性仍未得到充分探索。实证研究表明，该方法会导致意想不到的生产力损失，并在人机协作方面面临根本性挑战。为了弥补这一空白，本综述首次对基于大语言模型的Vibe Coding进行了全面系统的回顾，为这种变革性的开发方法建立了理论基础和实践框架。通过对1000多篇研究论文的系统分析，我们考察了整个Vibe Coding生态系统，并分析了关键的基础设施组件，包括用于编码的大语言模型、基于大语言模型的编码 Agent、编码 Agent 的开发环境以及反馈机制。我们首先将Vibe Coding作为一门正式学科引入，并通过约束马尔可夫决策过程对其进行形式化，该过程能够捕捉人类开发者、软件项目和编码 Agent 之间动态的三元关系。在此理论基础上，我们将现有实践综合为五种不同的开发模型：非约束自动化模型、迭代式对话协作模型、计划驱动模型、测试驱动模型和上下文增强模型，从而构建了该领域首个全面的分类体系。至关重要的是，我们的分析表明，成功的Vibe Coding不仅依赖于 Agent 的能力，还依赖于系统化的上下文工程、完善的开发环境以及人机协作开发模型。基于这些发现，我们指出了涵盖技术基础设施优化、安全机制和以人为本的设计考量等方面的关键挑战。最终，本综述既为人工智能增强型软件工程提供了概念基础，也为在这个快速发展的领域中探索的研究人员和实践者提供了技术路线图。

# 1.Introduction

大语言模型 (LLM) 通过能够流畅地理解和生成自然语言的对话系统，显著推动了人工智能的发展。LLM 在软件开发中的早期应用将其定位为辅助工具——开发人员使用自然语言提示来生成代码片段，但由于准确性存在显著局限性，因此需要在整个软件开发生命周期中进行人工审查和迭代调试。

GPT-4 和 Claude Sonnet 4 等先进架构的出现带来了质的飞跃，使得编码 Agent 能够通过 shell 命令、文件操作和测试执行等动态环境交互自主完成编程任务。这些 Agent 在实际编程任务中展现出了快速的进步。以 SWE-bench 为例，SWE-agent 通过自定义接口达到了 12.5% 的准确率，AutoCodeRover 通过代码搜索和故障定位实现了 19.0% 的准确率，Agentless 达到了 27.3%，OpenHands 在 SWE-bench Verified 测试中达到了 53%，而自改进 Agent 在 SWE-bench Verified 测试中也实现了 17% 至 53% 的性能提升。

随着 GPT-5 Pro 和 Claude Sonnet 4.5 等大语言模型的进步，基于 LLM 的编码 Agent 能力取得了显著突破，催生了“Vibe Coding”——一种开发者无需逐行检查代码，而是依赖 AI 生成的代码，并通过自然语言需求表达、执行观察和反馈的迭代循环来实现这一目标的范式。编码 Agent 的功能远不止于代码生成——它们能够自主配置环境、执行程序、自我诊断错误并更新实现。这显著提升了人类的信任度，并使其从传统的理解导向转向以结果为导向的验证。

然而，拥有强大的 Agent 并非万能。任务的复杂性暴露了非结构化自然语言指令的根本局限性，这些指令无法传达细致入微的需求和架构约束。实证研究表明，经验丰富的开发人员在使用 Cursor 和 Claude 时，完成时间反而增加了 19%，而非预期的生产力提升。有效的人机协作需要系统化的提示工程和上下文工程、结构化的指令以及在各种不同的交互类型中均衡分配 Agent。

为了弥补这一关键空白，本综述首次对基于大语言模型的 Vibe Coding 进行了全面系统的综述。如图 2 所示，我们将Vibe Coding定义为人类开发者、软件项目和编码 Agent 之间的一种动态三元关系，并通过约束马尔可夫决策过程首次将其正式定义为一门工程学科。基于此理论基础，我们将Vibe Coding工作流程提炼为五种开发模型——非约束自动化模型、迭代对话协作模型、计划驱动模型、测试驱动模型和上下文增强模型——这代表了对现有实践的首次全面综合。通过这一框架，我们：(1) 为理解软件开发中的人机协作建立了严谨的理论基础；(2) 为开发者提供选择和实施合适开发策略的可操作指导；(3) 指出涵盖技术基础设施、安全机制和人为因素的关键挑战和未来发展方向。这项工作既为新兴的人工智能增强软件工程领域奠定了概念基础，又为推进编码代理系统的研究和实践提供了技术路线图。

本文余下部分组织如下：第 2 节回顾了与 Vibe Coding 相关的综述和基础技术。第 3 节正式定义了 Vibe Coding，并通过约束马尔可夫决策过程 (CMP) 的形式化建立了其理论基础。第 4 节综述了用于编码的大语言模型 (LLM)，涵盖了数据基础、预训练技术和后训练方法。第 5 节考察了基于 LLM 的编码 Agent，分析了其规划能力、记忆机制、动作执行和协作架构。第 6 节探讨了关键基础设施组件，包括隔离的执行环境、交互式开发接口和分布式编排平台。第 7 节研究了反馈机制，涵盖编译器反馈、执行反馈、人工反馈和自我改进。第 8 节提出了我们提出的五种开发模型分类，并分析了它们的特征和应用。最后，第 9 节讨论了未来的影响和未解决的挑战，包括技术进步、安全考虑和以人为本的设计。

# 2.Related Work

## 2.1 Related Surveys


**Foundational LLM**。多项综述记录了大语言模型的发展历程，涵盖了语言模型架构、训练范式和功能。这些研究着重探讨了Transformer 的各种变体，尤其关注高效架构和长上下文处理能力。从BERT到ChatGPT的历史轨迹追溯了基础模型的发展，并分析了其中的机遇和风险。一些专门的综述则探讨了评估方法、从模型中心和数据中心角度分析的效率，以及包括文本生成和知识增强型预训练语言模型（PLM）在内的特定功能。

**In-Context Learning**。基于这些架构基础，研究转向了无需额外训练即可利用预训练模型的技术。提示工程和上下文学习已成为基础技术，相关分类涵盖了广泛的提示方法、应用、安全考量以及在自然语言处理 (NLP) 任务中的性能。上下文学习机制正在被探索，上下文工程也逐渐发展成为一门正式学科。思维链 (CoT) 推理已被证明特别有效，相关分类研究了 Chain-of-X 范式，并探讨了长 CoT 和多模态 CoT 推理。多模态大语言模型代表着一个快速发展的前沿领域，相关综述研究了跨多种数据模态的架构、训练方法以及视觉-语言集成。

**Post-Training**。当上下文学习不足以满足需求时，后训练方法可以提供途径，使模型与特定需求保持对齐，并增强其推理能力。强化学习方法，包括近端策略优化（PPO）、Q- learning 和Actor-Critic方法，已被广泛研究，尤其侧重于基于人类反馈的强化学习（RLHF）、基于人工智能反馈的强化学习（RLAIF）和直接偏好优化（DPO）。指令微调和有监督微调方法也得到了回顾，涵盖了数据集构建和训练策略，并探讨了用于增强指令执行能力的数据选择方法。对齐研究将方法分为外部对齐和内部对齐（考虑对抗性因素），同时探索了无需训练的对齐和个性化对齐技术。DPO作为一种无需强化学习的RLHF替代方案而出现，其分类体系对数据策略、学习框架和约束机制进行了分类。后训练范式涵盖了微调、对齐、推理、效率和领域适应，参数高效的方法包括低秩适应 (LoRA) 和适配器，并提供了计算开销的实验比较。

**Agent Systems**。工具使用和规划能力的整合将 LLM 从被动模型转变为主动 Agent。基础性综述建立了涵盖智能体构建、脑感知-动作架构和自主决策能力的框架，同时提供了涵盖推理和代码生成等基准测试的统一分类。多智能体系统的研究涵盖了智能体画像、通信协议以及复杂任务解决场景中的协作工作流程。智能体能力通过专门的综述进行探讨：工具使用（包括检索增强生成（RAG）和反馈学习）、规划机制（包括任务分解和记忆）、用于推理和工具执行的单智能体和多智能体架构，以及包含短期和长期分析的记忆机制。评估方法涵盖规划、工具使用、自我反思和特定应用基准测试。特定领域的应用涵盖了网络自动化、生命科学和材料科学领域的科学发现、具有图形用户界面交互的操作系统 Agent 以及具有反馈回路和终身学习能力的自演化 Agent。尤其值得一提的是，近期的一些综述研究了在软件开发生命周期中，采用单 Agent 和多 Agent 架构的编码 Agent，涵盖了规划、上下文管理以及与基准测试框架的工具集成。

## 2.2 Preliminary

**Reinforcement Learning for Code Generation**。将强化学习应用于代码生成需要可执行的反馈信号，其机制也从基本机制发展到复杂的训练范式。早期方法将预训练语言模型与深度强化学习相结合，利用单元测试反馈和关键采样，在竞争性基准测试中取得了优异的性能。基于执行的方法利用编译器反馈进行性能优化（PPO），实现实时优化。高级强化学习框架采用多粒度单元测试反馈，将代码生成分解为课程子任务并进行细粒度优化，使用基于排序的对齐机制，并利用编译​​器反馈进行分组相对策略优化，从而达到具有竞争力的性能。

**Autonomous Coding Agent Systems**。除了监督式代码生成之外，自主 Agent 通过专门的架构和多 Agent 协作来处理完整的软件工程任务。单 Agent 系统引入了定制的 Agent-计算机接口，实现了强大的基准测试性能；将结构感知代码搜索与基于频谱的故障定位相结合，以经济高效的方式解决问题；并证明简单的分层定位可以超越复杂的 Agent。存储库级代码生成将编程工具与 Agent 策略相结合，展现出显著的性能提升；而迭代检索生成方法则改进了存储库评估基准测试的基线性能。多 Agent 框架在整个开发过程中采用专门的角色。这些框架分配了不同的程序员、测试设计者和测试执行者 Agent，从而在降低 token 消耗的同时实现了高通过率，将标准化操作流程编码到装配线范式中，并通过基于角色的协作实现了近乎完美的任务完成，还实现了具有双 Agent 通信的聊天链架构，以最低的成本覆盖了整个软件开发生命周期。专门的框架复制人类编程周期，研究测试驱动开发原则，证明预先提供测试可以持续改进，并分析自我修复机制，揭示性能提升有限，受到自我反馈能力的瓶颈。

**Function Calling**。高效的 Agent 系统需要工具使用、函数调用和执行基础设施等机制，以便与外部系统和API进行交互。函数调用框架能够训练语言模型，使其能够通过简单的API（只需极少的演示）进行工具的自监督使用；利用教师模型生成与工具相关的指令数据；并利用大规模API数据集，在细粒度任务上进行多任务学习。执行和交互环境为轻量级强化学习框架提供安全执行支持，支持多种编程语言；使用可执行代码作为统一的动作空间，其性能优于其他格式，并支持专门的指令数据集和微调模型；此外，还将蒙特卡洛树搜索与外部反馈相结合，以实现有意识的问题解决。优化和部署方面的进步能够自动识别可并行化的函数调用，从而显著降低延迟并节省成本；支持边缘部署，使紧凑型模型能够在本地达到大型模型的性能；并协调专门的智能体进行工具选择、执行和校准，从而提高成功率。检索、评估和基础设施贡献提供了大规模基准测试，表明从各种数据存储中检索数据可以显著提高性能，将工具使用能力分解为 API 操作的评估方面，开发用于代码审查自动化的多智能体系统，在关键审查任务上取得了显著成果，实现了用自然语言或代码语言编程的可定制对话智能体，并提供了大量的指令-API 对数据集，展示了跨语言传输，使开源模型能够在新的 API 调用上超越专有替代方案。

**Supervised Fine-Tuning**。强化学习的替代方案是有监督微调和指令微调方法，这些方法已成为代码模型训练的基础。指令演化方法通过迭代演化代码指令来实现具有竞争力的性能，而  self-instruction 方法则引导指令执行能力。完全透明的自对齐流水线无需专有蒸馏即可实现训练，而大规模指令数据集则结合了多种指令生成方法。专门的调优方法针对以安全为中心的代码生成，显著提高了代码安全性；优化代码生成；并通过自调试方法和迭代改进，无需额外训练即可进行代码编辑、调试和改进。代码基础模型采用带有扩展上下文窗口的仓库级预训练，在多种语言上进行训练，并采用中间填充目标和个人身份信息 (PII) 脱敏，将 GitHub 问题和文档与仓库级训练相结合，并通过大规模采样和过滤策略实现竞赛级性能。

# 3.Vibe Coding: The Engineering of Managing Coding Agents

## 3.1 Definition of Vibe Coding

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/9f349a1fc9284c0d8925b21864c89e5e.png)

本文将 Vibe Coding 定义为一种基于大语言模型的软件开发工程方法。**如图2所示，其核心在于构建人类开发者、软件项目和编码 Agent 之间的动态三元关系**。在这种范式下，人类开发者从直接的代码编写者转变为意图表达者、上下文管理者和质量仲裁者。项目不再局限于静态代码库，而是扩展为包含代码库、数据库和领域知识的多维信息空间。编码 Agent 作为智能执行器，在人类意图和项目约束的双重指导下执行代码生成、修改和调试。

**Formalization of the Triadic Relationship**。我们将 Vibe Coding 建模为一个动态交互系统，该系统由三元组 $\mathcal V = ⟨\mathcal H, \mathcal P, \mathcal A_θ ⟩$ 定义，其中：
- $\mathcal H$：具备需求认知能力 $\mathcal H_{req}: \mathcal D → \mathcal I$（将领域需求 $\mathcal D$ 转化为指令 $\mathcal I$）和质量辨别能力 $\mathcal H_{eval}: \mathcal O → \{0, 1\} × \mathcal F$（通过接受/拒绝决策和反馈 $\mathcal F$ 来判断输出 $\mathcal O$）的人类开发人员。
- $\mathcal P$：软件项目，表示为项目上下文空间 $\mathcal P = ⟨\mathcal C_{code}, \mathcal C_{data}, \mathcal C_{know}⟩$，分别对应于代码库、数据库和领域知识。
- $\mathcal A_{\theta}$：编码 Agent，一个由 $θ$ 参数化的大语言模型，执行条件生成函数 $\mathcal A_θ: \mathcal I × \mathcal P × \mathcal E → \mathcal O$。

三方合作可以建模为约束马尔可夫决策过程（约束MDP），其中人类定义目标空间和约束边界，项目提供状态空间和转换约束，而 Agent 执行策略和状态转换：

$$\mathcal V_{MDP}=⟨\mathcal S_{\mathcal P},\mathcal A_{\mathcal H->\mathcal A_{\theta}},\mathcal T_{\mathcal A_{\theta}|\mathcal P},\mathcal R_{\mathcal H},\gamma⟩,\tag{1}$$

其中，状态空间 $\mathcal S_{\mathcal P}$ 由项目的当前状态定义，动作空间 $\mathcal A_{\mathcal H→\mathcal A_θ}$ 由人类对智能体行为的指令触发，转移函数 $\mathcal T_{\mathcal A_θ|\mathcal P}$ 受项目规范约束，奖赏函数 $\mathcal R_{\mathcal H}$ 由人类评估决定，$γ$ 为衰减因子。

**Agent’s Conditional Generation Process**。给定人类意图 $\mathcal I$、项目上下文 $\mathcal K ⊆ \mathcal P$（从项目信息空间中检索到的相关子集）和执行环境 $\mathcal E$，Agent 以自回归方式生成代码序列 $Y = (y_1, . . . , y_T)$，其联合概率分解为：

$$P_{\theta}(Y|\mathcal I,\mathcal K,\mathcal E)=\prod^T_{t=1}P_{\theta}(y_t|y_{< t},\mathcal C_t),\tag{2}$$

其中 $\mathcal C_t = \mathcal A(\mathcal I, \mathcal K, \mathcal E, y_{<t})$ 表示步骤 $t$ 的动态上下文，由高级组装函数 $\mathcal A$ 协调。上下文组件 $c_i$ 对应于三元关系中的不同信息源：

**Human Layer**：
- $c_{instr}$：系统指令和任务要求。

**Project Layer**：
- $c_{code}$：代码库（源代码、API接口、架构设计）。
- $c_{data}$：数据库（持久数据、数据模式）。
- $c_{know}$：领域知识（文档、规范、最佳实践）。

**Agent Layer**：
- $c_{tool}$：可调用工具（编译器、测试框架、版本控制）的定义和签名。
- $c_{mem}$：历史交互记忆（多轮对话背景、先前决策记录）。
- $c_{tasks}$：当前任务（待处理操作、任务队列、执行状态）。

**Optimization Objective of Vibe Coding**。从三元视角来看，Vibe Coding 的核心挑战是：在有限的上下文窗口 $L_{\max}$ 内，识别最优的上下文编排策略 $\mathcal{F}^* = \{ \mathcal{A}, \text{Retrieve}, \text{Filter}, \text{Rank}\}$，以最大化生成质量。定义奖赏函数 $R : \mathcal{O} \times \mathcal{O}^* \rightarrow \mathbb{R}$，用于衡量生成输出与人类期望的对齐程度。给定任务分布 $\mathcal{T}$，其优化目标为：

$$
\mathcal{F}^* = \arg\max_{\mathcal{F}}
\mathbb{E}_{\tau \sim \mathcal{T}}
\left[ R\big(P_{\theta}(\mathcal{Y} \mid C_{\mathcal{F}}(\tau)), \mathcal{Y}^*_{\tau} \big) \right]
\quad \text{s.t.} \quad |C_{\mathcal{F}}(\tau)| \le L_{\max}
\tag{3}
$$

其中，$C_{\mathcal{F}}(\tau)$ 表示策略 $\mathcal{F}$ 为任务 $\tau$ 从项目 $\mathcal{P}$ 中检索并过滤得到的上下文，$\mathcal{Y}^*_\tau$ 表示人类心智模型中的理想输出。该优化问题本质上是在指数级大的项目信息空间中，寻找能让 Agent 生成最大信息增益的上下文子集。

**Human-Agent Collaborative Loop and Task Evolution**。 Vibe Coding 的核心机制是通过**持续的人类反馈**引导 Agent 朝项目目标前进，并且**显式支持人类迭代式地扩展约束并引入新任务**，从而形成一个动态演化的需求空间。令 Agent 在第 $k$ 次迭代产生输出 $o_k \in \mathcal{O}$。人类监督函数 $\mathcal{H} : \mathcal{O} \times \mathcal{R} \times \mathcal{I} \rightarrow 2^\mathcal{O} \times (\mathcal{F} \cup \mathcal{I}_{\text{new}})$ 在执行结果 $\mathcal{R}$ 与当前指令 $\mathcal{I}_k$ 的约束下，返回一个可接受的子集 $\mathcal{A}_k \subseteq o_k$ 以及一个校正信号 $\delta_k$。迭代式演化过程定义如下：

$$
(o_{k+1}, \mathcal{I}_{k+1}) =
\begin{cases}
(o_k, \mathcal{I}_k) & \text{if } \mathcal{A}_k = o_k ;\text{(full acceptance, terminate)} \\
(\mathcal{A}_{\theta}(o_k \setminus \mathcal{A}_k ; \delta_k, \mathcal{I}_k, \mathcal{K}), \mathcal{I}_k) & \text{if } \delta_k \in \mathcal{F}\text{(local refinement)} \\
(\mathcal{A}_{\theta}(\mathcal{I}_k \cup {\delta_k}, \mathcal{K}), \mathcal{I}_k \cup {\delta_k}) & \text{if } \delta_k \in \mathcal{I}_{\text{new}}\text{(requirement expansion)}
\end{cases}
\tag{4}
$$

其中，$(\mathcal{A}_k, \delta_k) = \mathcal{H}(o_k, \mathcal{R}_k, \mathcal{I}_k)$，$\mathcal{R}_k$ 表示在环境 $\mathcal{E}$ 中运行 $o_k$ 获得的执行反馈。

**Formalization of Iterative Task Expansion**。

## 3.2 Why Vibe Coding

Vibe Coding 将软件开发从被动协助转变为协作伙伴关系，以应对民主化、工作流程效率和生态系统扩展方面的挑战。

**Team-Scale Capabilities for Individual Developers**。Vibe Coding 使单个开发者能够交付团队规模的功能。传统的生产应用需要协调前端、后端、数据库、安全、DevOps 和 QA 等多个领域的专家，这会带来巨大的开销。编码 Agent 可以提供跨领域的多元化专业知识。开发者专注于需求，而 Agent 则负责跨技术栈的实现。这通过上下文工程降低了学习成本。现在，单个开发者无需接受正式培训即可实现云基础设施和性能优化，这使得资源受限的实体能够将原型开发时间从数周缩短到数天。

**Continuous Development and Quality Convergence**。Vibe Coding 旨在平衡开发速度和代码质量——这两个目标历来相互冲突。传统的开发流程需要在交付速度和测试严谨性之间做出权衡。Vibe Coding 通过摆脱人为限制的自主迭代来提升这两方面。Agent 支持全天候运行：自动化测试、重构和性能分析。自动化机械性任务可以释放认知资源，用于设计和优化。Agent 通过快速迭代实现详尽的探索，而人工监督则验证架构决策。

**Broadening the Software Creator Ecosystem**。Vibe Coding 通过降低技术门槛实现了开发的民主化。传统开发需要大量的编程知识才能实现想法。自然语言成为主要的创作界面。领域专家——例如医疗从业者、教育工作者和设计师——无需计算机科学教育即可表达需求。这丰富了创新来源，使以往被忽视的视角得以体现。经济影响体现在创作者经济的扩张：领域专家无需技术合伙人即可将专业工具货币化。这与之前的民主化浪潮相呼应，代表着软件素养从专业技能向广泛普及能力的演变。

# 4.Large Language Models for Coding

![在这里插入图片描述](https://i-blog.csdnimg.cn/direct/ef520d9276ab498ebdca8373edb7bf99.png)

## 4.1  Data Foundation of Code LLMs

### 4.1.1 Pre-training Code Corpora

代码 LLM 需要来自各种来源的大规模训练数据。这些模型依赖于主要来自 GitHub 和 Stack Overflow 等开放平台的大规模代码语料库，并根据存储库星标、文档完整性和社区参与度等指标进行质量过滤。

训练数据集的组成和整理策略差异显著，主要有两种方法：一种是注重深度的策略，侧重于流行语言以确保高质量；另一种是注重广度的策略，涵盖多种语言以扩大覆盖范围。Stack 数据集采用注重深度的方法，提供了 3.1 TB 的宽松许可源代码，涵盖 30 种编程语言，并严格关注许可和数据来源。CodeParrot 也类似地完全使用 GitHub 代码进行训练，以实现流行语言的深度覆盖。相比之下，注重广度的方法则涵盖多种语言以达到最大覆盖范围。 Stack v2 将覆盖范围大幅扩展至 67.5 TB，涵盖 619 种编程和标记语言；GPT-Neo 利用了各种混合语料库，包括“the Pile”；CodeLlama 使用了 SlimPajama 的 6270 亿个 token，并结合了来自 The Stack 的代码；Arctic-SnowCoder 则使用了一种经过筛选的组合，产生了 4000 亿个 token。

数据质量推动了复杂的处理流程的发展，RefineCode 整合了 607 种语言的 130 多条精心设计的语言特定过滤和清理规则，以确保句法和语义的有效性，而 SwallowCode 则实现了全面的四阶段流程，执行语法验证、质量评估、去重和基于 LLM 的重写，以提高训练数据的质量。

### 4.1.2 Instruction & Preference Datasets

除了原始代码语料库之外，指令遵循还需要经过精心整理的训练数据。因此，代码 LLM 模型在各种编程任务中都展现出了卓越的能力，其中指令微调是提升指令遵循能力和解决方案生成质量的关键技术。这些指令数据集通常由两个主要来源编译而成：采用宽松许可的源代码库和合成构建的指令数据。该领域值得关注的指令数据集包括：CommitPack，它拥有高达 4TB 的原始数据，经过精心筛选，最终得到 2GB 的高质量代码，并附有能够捕捉开发者意图的提交信息指令；OpenCodeInstruct，它是目前最大的开源数据集，包含500万个涵盖多种编程语言和任务类型的多样化样本；以及SynCode-Instruct，它提供了近200亿个合成指令遵循示例。对于偏好学习应用，CodeUltraFeedback 提供 10,000 条编码指令，每条指令都与来自 14 个不同 LLM 的四个不同响应配对，所有这些都由 GPT-3.5 进行全面评估，以建立质量排名，而 PLUM 框架创新地采用 GPT-4 生成的单元测试，根据功能正确性建立自动偏好排名。

高质量指令数据集构建方法已从成本高昂且耗时的人工标注过程显著发展到更具可扩展性的合成生成方法，这些方法在保持质量的同时降低了成本。Self-Instruct 范式率先采用从有限的种子示例引导的方法，利用语言模型通过精心设计的指令输入输出流水线生成新的指令；而 Evol-Instruct 则引入了逐步增加复杂度的概念，通过迭代地重写和增强初始指令来创建更具挑战性和多样性的训练示例。OSS-Instruct 通过系统地集成真实世界的开源代码片段作为种子，生成多样化且上下文真实的指令数据，从而更好地反映实际编程场景，进一步推动了该领域的发展。质量增强技术已经变得非常复杂，采用了诸如 CoachLM 的基于 LLM 的迭代重写等方法来提高教学清晰度和任务一致性，以及 CaR（评论和修改）方法，该方法使用与专家偏好一致的专门评分模型来过滤和改进合成数据，这些合成数据方法的有效性已通过 Nvidia 的 Nemotron-4 等系统得到证明，该系统使用 98% 的合成生成对齐数据实现了最先进的性能。

## 4.2 Pre-training Techniques

### 4.2.1 Pre-training Objectives

用于代码的大语言模型利用了从 BERT 和 GPT 架构继承的迁移学习范式，在任务特定微调之前，使用大规模数据进行预训练已被证明特别有效，尤其是在标注数据有限的情况下，大语言模型的性能优于领域特定模型。代码特定的预训练目标超越了传统的 MASK 语言建模方法，其创新之处包括 GraphCodeBERT 的数据流预测（可捕获代码中的语义关系）以及 CodeT5 和 DOBF 中利用编程语言结构的变量命名任务。

预训练的根本目的是从大规模无标签数据集中灌输通用知识和模式识别能力，目前已有几种成熟的范式占据主导地位。自回归语言模型基于所有先前的上下文预测序列中的下一个 token，而 MAKS 语言模型则侧重于利用前后上下文预测随机掩码的 token，以实现双向理解。其他一些备受关注的目标包括：用于预测序列中缺失跨度的填充任务，以及用于从给定前缀生成后续 token 的前缀语言模型。

MASK 语言模型是代码理解任务的主流方法，它直接建立在 BERT 在自然语言处理领域取得的显著成功之上。这种方法主要被 CodeBERT 等纯编码器模型所采用，CodeBERT 利用基于 RoBERTa 的架构进行双向代码理解。标准实现对大约 15% 的输入 token 进行采样，其中 80% 的采样词元被替换为特殊的 [MASK] token，从而实现双向的基于上下文的预测。

实现细节因模型而异，CodeBERT 应用了 MLM 并辅以替换 token 检测来提高鲁棒性，而 GraphCodeBERT 则通过下文讨论的结构感知功能对其进行了扩展。

自回归语言模型是代码生成任务的基础方法，它仅基于前面的上下文预测下一个 token。像 CodeGPT 这样的纯解码器模型有效地利用了GPT架构中强大的基于Transformer的解码器来实现这一目标。最近，像 CodeLlama 这样的模型通过创新的中间填充目标扩展了这一范式，使模型能够根据前缀和后缀上下文生成缺失的代码段，这在代码补全任务中被证明非常有效。

与单向预测相比，去噪目标已被证明对编码器-解码器架构在跨度级重构任务中非常有效。PLBART 首先在 BART 的序列到序列架构的基础上，将去噪方法应用于编码，而现代统一模型越来越多地在综合多任务框架中采用复杂的去噪策略，例如 CodeT5+，它将跨度去噪与对比学习目标协同结合起来。

结构感知目标融合了编程语言固有的独特结构特征，包括抽象语法树、控制流图和数据流关系。GraphCodeBERT 整合了数据流图，显式地编码了跨代码段变量之间的语义关系，同时引入了专门的结构感知任务，例如代码结构边缘预测，这些任务需要理解语法和语义代码组织。对比学习显式地最小化语义相似代码函数之间的表示距离，同时最大化不相似代码之间的距离，是一种强大的代码模型训练技术。UniXcoder 通过复杂的多模态对比学习来实现这一方法，它将自然语言注释和线性化的抽象语法树表示统一到一个共享的语义空间中，而 ContraCode 利用自动编译器转换生成语义等价的代码变体，以实现稳健的对比数据增强。多模态预训练策略利用多种互补的数据模态来增强模型能力，CodeBERT 首先通过精心对齐的双模态自然语言-编程语言对来学习通用代码表示，而像 CodeT5+ 这样的高级模型则实施复杂的两阶段训练程序，包括首先在大量纯代码数据上进行单模态预训练以建立编程知识，然后在精心整理的代码-文本对上进行双模态预训练，并进行显式的跨模态对齐学习以连接自然语言和编程语言。

### 4.2.2 Continual Pre-training Strategies

## 4.3 Post-training Techniques

# 5.LLM-based Coding Agent
